## 📔 4장: 변수

### ✨ 4.1: 변수란 무엇인가? 왜 필요한가?

컴퓨터는 CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억하며 연산의 결과도 메모리에 저장된다. 만약 `10 + 20` 같은 연산의 결과를 재사용하려면 어떻게 해야 할까? 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지도 않고 코드가 실행되기 전에는 메모리 주소를 알 수도 없기 때문에 주소를 통한 접근은 올바르지 않다.  
➡️ 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어들여 재사용하기 위해 **변수**라는 메커니즘이 제공된다.

```
변수: 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
```

간단히 말하자면 변수는 값의 위치를 가리키는 상징적인 이름이다. 이 덕분에 개발자는 특정 값을 저장하고 참조하기 위해 실제 메모리 주소를 직접 알고 있을 필요가 없다.  
변수에 값을 저장하는 것을 **할당**이라고 하며 변수에 저장된 값을 읽어들이는 것을 **참조**라고 한다.

### ✨ 4.2: 식별자

변수 이름을 식별자라고도 부른다. 식별자는 변수 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 관계 또한 메모리에 저장된다.  
**이처럼 식별자는 값이 아니라 메모리 주소를 기억한다.** 즉, 식별자는 변수 값이 아니라 메모리 값에 붙인 이름이라고 할 수 있다.

### ✨ 4.3: 변수 선언

**변수 선언**: 변수를 생성하는 것 (값을 저장할 메모리 공간을 확보하고, 변수 이름과 확보된 공간의 주소를 연결해 값을 저장할 수 있도록 준비하는 것)  
변수를 사용하려면 반드시 선언을 해야 하며 선언 시에는 `var`, `const`, `let` 키워드를 사용한다.

```
var score;
```

위의 변수 선언문은 값을 저장할 메모리 공간을 확보하고 변수 이름을 등록한다. 선언만 한 후 아직 값을 할당하지는 않았지만 **암묵적으로 `undefined` 값이 할당된다**.

```
변수 선언의 단계

1️⃣ 선언 단계: 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알림
2️⃣ 초기화 단계: 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화함
```

`var` 키워드를 사용해 변수를 선언하면 위의 두 단계가 동시에 진행된다. 이렇게 변수를 사용하려면 선언을 반드시 해야 하며 선언하지 않고 참조하려 하면 `ReferenceError`이 발생한다.

### ✨ 4.4: 변수 선언의 실행 시점과 변수 호이스팅

자바스크립트 코드는 인터프리터에 의해 한 줄씩 순서대로 진행되지만, 변수 선언은 그에 앞서 먼저 실행된다. 이렇게 소스코드 평가 과정이 끝난 후에서야 코드가 한 줄씩 순서대로 진행된다.  
➡️ 그래서 **변수가 어디에 선언되어 있든 상관없이 어디서든지 변수를 참조하는 것이 가능하다.**  
이것을 마치 변수 선언문이 코드 맨 위로 끌어올려진 것처럼 동작한다고 해서 **변수 호이스팅**이라고 부른다. 변수 선언뿐 아니라 모든 선언문은 호이스팅된다.

### ✨ 4.5: 값의 할당

`=`: 할당 연산자 (우변의 값을 좌변의 변수에 할당)  
바로 위에서 봤듯이 변수 선언은 런타임 이전에 먼저 실행되지만, **값의 할당은 런타임에 실행된다.**

```
console.log(score);  // undefined

var score;
score = 100;

console.log(score);  // 100
```

그래서 위의 코드를 실행해 보면 첫번째 `console.log`로는 `undefined`가 출력되며, 두번째로는 `100`이 출력된다. 위 코드의 두번째 줄을 `var score = 100`이라고 단축해 표현해도 결과는 같다.
**변수에 값을 할당할 때, 이전에 할당되었던 `undefined`를 지우고 같은 공간에 새로운 값을 저장하는 것이 아니라, 새로운 공간을 확보해 새로운 값을 저장하는 것이다.**

### ✨ 4.6: 값의 재할당

**재할당**: 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것  
`var` 키워드로 선언한 변수는 값을 재할당할 수 있다. 만약 재할당이 불가능하다면 그건 변수가 아니라 상수라고 한다. (`const`로 선언한 변수는 재할당이 불가능)  
값이 재할당되어 더이상 쓸모가 없어진 그 전의 값은 그 어떤 식별자도 참조하고 있지 않으므로 가비지 콜렉터에 의해 메모리에서 자동 해제된다. (자바스크립트는 매니지드 언어이기에 메모리 해제는 가비지 콜렉터가 알아서 수행하며 사람이 관여할 수 없음)

---

### ✨ More on Hoisting

#### `var` declarations

Being able to reference a variable in its scope before the line it is declared, without throwing a `ReferenceError`, but the value is always `undefined` (위에서 공부한 것과 같은 내용)

#### `let`, `const` declarations

The declaration of the variable causes behavior changes in its scope before the line in which it is declared.

이렇게 `var` 키워드로 선언된 변수와 `let`, `const`로 선언된 변수들의 호이스팅에는 차이가 있다. 후자로 선언된 변수들은 호이스팅이 되지 않는다고 보는 사람들도 있다고 한다.

Reference: https://developer.mozilla.org/en-US/docs/Glossary/Hoisting
