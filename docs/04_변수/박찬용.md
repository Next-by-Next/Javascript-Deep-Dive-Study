## 📔 4장: 변수

### 4.1: 변수란 무엇인가? 왜 필요한가?
사람은 계산과 기억을 모두 두뇌에서 하지만
but 컴퓨터는 연산과 기억을 수행하는 부품이 나눠져 있다.   
컴퓨터는 **CPU**를 통해 연산하고, **메모리**를 사용해 데이터를 기억한다.

##### 메모리
    메모리는 데이터를 저장할 수 있는 메모리 cell의 집합체다.
    메모리 cell 하나의 크기는 1바이트(8bit)이다. 

##### 변수
    하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
##### 할당(assignment)
    변수에 값을 저장하는 것을 말한다
##### 참조(reference)
    변수에 저장된 값을 읽어 들이는 것을 말한다.

-> 결국 변수 이름을 사용해서 참조를 요청하면, 자바스크립트 엔진이 메모리 공간에 저장된 값을 반환한다.

---
### 4.2: 식별자

**변수 이름을 식별자라고도 부른다.**
식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름을 말한다.

이처럼 식별자는 값이 아니라 **메모리 주소를 기억한다**.    
즉, 식별자는 변수 값이 아니라 메모리 값에 붙인 이름이라고 할 수 있다.

---
### 4.3: 변수 선언

**변수 선언**: 변수를 생성하는 것 (값을 저장할 메모리 공간을 확보하고, 변수 이름과 확보된 공간의 주소를 연결해 값을 저장할 수 있도록 준비하는 것)  
변수를 사용하려면 반드시 **선언**을 해야 하며 선언 시에는 `var`, `const`, `let` 키워드를 사용한다.


#### var, let , const
* ES6에서 let, const를 도입한 이유가 var의 단점을 보완하기 위해서이다. 
* var let const는 모두 호이스팅 된다 but, **var만 undefined로 자동 초기화**가 된다.
* var은 let, const와 달리 함수레벨 스코프를 가진다.
* let과 const는 블록레벨 스코프를 가져 모든 코드블록(if for while try/catch 등)에서 지역스포크를 가진다.


변수 선언문은 값을 저장할 메모리 공간을 확보하고 변수 이름을 등록한다. 
선언만 한 후 아직 값을 할당하지 않으면 **`undefined`** 라는 원시 타입의 값으로 초기화된다.

```
자바스크립트 엔진의 변수 선언 단계
1️⃣ 선언 단계  : 변수 이름을 등록해 자바스크립트 엔진에 변수의 존재를 알림
2️⃣ 초기화 단계: 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화함
```
결국 변수를 사용하려면 반드시 `변수의 선언` 이 먼저 필요하다.
만약 선언하지 않은 식별자에 접근하면 **ReferenceError(참조에러)** 가 발생한다. 

---
### 4.4: 변수 선언의 실행 시점과 변수 호이스팅
```
console.log(score); //undefined
var score;  //변수선언
```
위의 코드에서, 참조 에러가 발생하지 않고 `undefined` 가 출력된다.

그 이유? **변수 선언이 런타임이 아니라, 그 이전 단계에서 먼저 실행되기 때문이다.**

즉 자바스크립트 엔진에서 **변수 선언이** 어디있든지, 다른 코드보다 **먼저** 실행된다.
➡️ 변수뿐 아니라 모든 선언문(함수,클래스 등)은 위로 끌려올려진 것처럼 동작하는 **변수 호이스팅**이라고 부른다. 

### 4.5: 값의 할당

`=`: 할당 연산자 -> 우변의 값을 좌변의 변수에 할당한다.  
바로 위에서 봤듯이 변수 선언은 런타임 이전에 먼저 실행되지만, **값의 할당은 소스코드가 순차적으로 실행되는 시점인 _런타임_ 에 실행된다.**

```
console.log(score);  // undefined
var score;
score = 100;
console.log(score);  // 100
```

그래서 위의 코드를 실행해 보면, score의 선언이 호이스팅되어서 undefined가 먼저 출력된다.   
그 후, score변수에 100이라는 값이 할당된 이후에는 score변수의 값인 80이 제대로 출력된다.   
**변수에 값을 할당할 때, 이전에 할당되었던 `undefined`를 지우고 같은 공간에 새로운 값을 저장하는 것이 아니라, 새로운 공간을 확보해 새로운 값을 저장하는 것이다.**

---
### 4.6: 값의 재할당

`재할당`: 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것
```
var score = 80;
score = 90;
```
var키워드로 선언한 변수는 값 재할당이 가능하다. 반면 재할당이 불가능하다면 **상수(constant)** 라고 한다.

#### 재할당의 메모리관점
**새로운 메모리 공간**을 확보하고, 그 메모리 공간에 새로운 값을 저장한다.   
재할당은 이전값이 저장되어 있던 메모리 공간을 지우고, 그 메모리 공간에 재할당한 값을 저장하는것이 아니다.   
    -> 필요가 없어진 이전값은 가비지콜렉터에 의해 메모리에서 자동 해제된다.
