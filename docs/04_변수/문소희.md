# 🚀 변수 (Variable)

## ⭐️ 1. 변수

### 💬 변수

하나의 값을 저장하기 위해 확보한 **메모리 공간 자체** 또는 그 **메모리 공간을 식별하기 위해 붙인 이름으로,** 값의 위치를 가리키는 `상징적인 이름`이다. 예시를 보고 이야기해 보자!

```javascript
var result = 10 + 20;
```

`10 + 20`이라는 연산을 통해 `30`이라는 결과가 생성되면 얘는 메모리 공간에 저장된다. 그리고 메모리 공간에 저장된 `30`을 쉽게 데려와 재사용할 수 있게끔 메모리 공간에 상징적인 이름 `result`를 붙여 준다. 여기서 `result`가 바로 변수다!

메모리 공간의 메모리 주소는 사람이 직관적으로 이해하기 어려우니까 사람 눈높이에 맞춘 언어로 이름을 붙여 준 게 변수 이름이라고 생각하면 되시겠다.

### 🤔 그래서 왜 필요한데?

우선 `메모리`라는 개념을 알 필요가 있다. `메모리`는 데이터를 저장할 수 있는 `메모리 셀`의 집합체인데, 메모리 셀 하나의 크기는 `1바이트`이며, 컴퓨터는 메모리 셀의 크기 단위로 데이터를 저장하거나 읽어들인다.

각 메모리 셀은 고유의 `메모리 주소`를 가지는데, 주소는 메모리 공간의 위치를 나타내고 메모리의 크기 만큼 정수로 표현한다. 이후 이 공간에 저장되는 데이터들은 모두 컴퓨터의 저장 방법을 따라 2진수로 저장된다. 그리고 CPU가 값을 읽어 연산을 수행하는 것이다!

요약하자면 `메모리`는 데이터를 기억하는 친구, `CPU`는 연산을 수행하는 친구다.

> 근데 이게 변수랑 무슨 상관인데요? 🧐

CPU가 성공적으로 연산을 끝내면 30은 새로운 공간을 확보해 저장된다. 그런데 그 30을 CPU가 재사용할 수 있을까? **'답은 재사용할 수 없다'이다.**

만일 30을 사용하고 싶다면 메모리 공간에 직접 접근해야 하는데, 메모리 주소를 통해 직접 접근하는 것은 치명적 오류를 발생시킬 가능성이 높은 매우 위험한 일이라 자바스크립트는 애초에 개발자의 직접적인 메모리 제어를 허용하지 않는다.

그래서 프로그래밍 언어는 기억하고 싶은 것을 메모리에 저장하고, 저장된 값을 읽어 들여 재사용하기 위해 변수라는 메커니즘을 제공하는 것이다.

## ⭐️ 2. 식별자

**어떤 값을 구분해서 식별할 수 있는 고유한 이름을 말한다.** 값은 메모리 공간에 저장되어 있기 때문에 이를 구별하기 위해 식별자는 **값이 저장되어 있는 메모리 주소를 기억하는 역할을 한다.**

여기서 주의해야 할 점은 값을 저장하는 것이 아니라 메모리 주소를 기억한다는 건데, 완전 쉽게 말하자면 그냥 메모리 주소의 이름이 식별자다. 그리고 선언을 하게 되면 자바스크립트 엔진에 `나 여기 있어요! 🥺` 하고 존재를 알릴 수 있게 된다.

## ⭐️ 3. 변수 선언

### 💬 변수 선언

**변수를 생성하는 것을 말한다.** 조금 더 자세하게 말하자면, 값을 저장하기 위한 메모리 공간을 확보하고 변수 이름과 확보된 메모리 공간의 주소를 연결해 값을 저장할 수 있게 준비하는 것이다! 이렇게 확보된 메모리 공간은 확보가 해제되기 전까지 아무도 해당 공간을 사용할 수 없도록 보호된다.

변수를 사용하기 위해서는 반드시 선언이 필요한데, 변수를 선언할 때 사용하는 키워드에는 `var`, `let`, `const`가 있다.

### 💬 변수 선언 단계

**선언 단계**: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다. <br/>
**초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

`초기화`는 변수가 선언된 이후 최초로 값을 할당하는 것을 말하는데, var 키워드로 변수를 선언하게 되면 **얌묵적으로 초기화(undefined)가 자동 수행된다.** 초기화 단계를 거치지 않고 선언된 변수를 바로 참조하려고 하면 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 쓰레기 값이 남을 수 있다. 하지만 var 키워드는 암묵적으로 초기화를 자동 수행하므로 이런 위험으로부터 안전하다!

만일 변수를 선언하지 않고 참조하게 되면 등록된 식별자를 찾을 수 없다는 `참조 에러(Reference Error)`를 발생시킨다.

### 🚨 var 키워드의 단점

`var` 키워드는 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다. 이로 인해 의도치 않게 전역 변수가 선언되어 심각한 부작용이 발생할 수 있다는 치명적인 단점이 존재한다.

이를 보완하기 위해 ES6부터 `let`과 `const` 키워드가 나타났다!

### 🤔 변수 이름은 어디에 등록될까?

**변수 이름을 비롯한 모든 식별자는 값과 함께 실행 컨텍스트 내에 키/값 형식인 객체로 등록되어 관리된다.**

`실행 컨텍스트`는 자바스크립트 엔진이 소스 코드를 평가하고 실행하기 위해 필요한 환경을 제공하고, 코드의 실행 결과를 실제로 관리하는 영역이다.

## ⭐️ 4. 변수 선언의 실행 시점과 변수 호이스팅

### 💬 변수 선언 실행 시점

**`변수 선언`은 소스 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행된다.**

자바스크립트 엔진은 소스 코드를 한 줄씩 순차적으로 실행하기 전, 소스 코드의 평가 과정을 거친다. 이때 변수 선언을 포함한 모든 선언문을 찾아 먼저 실행한 뒤 평가 과정이 끝나면 모든 선언문을 제외한 소스 코드를 한 줄씩 출력한다.

> 요약하자면 **변수 선언이 어디에 있든 자바스크립트 엔진은 얘를 가장 먼저 실행한다!** 그래서 어디에서든지 변수를 참조할 수 있는 것이다.

### 💬 변수 호이스팅

**변수 선언문이 코드의 선두로 끌여 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다.** 아래는 `변수 호이스팅`의 예제이다.

```javascript
console.log(score); // undefined

var score;
```

## ⭐️ 5. 값의 할당

### 💬 할당 (assignment: 대입, 저장)

**변수에 값을 저장하는 과정이다.** 변수에 값을 할당할 때는 할당 연산자인 `=`를 사용하는데, 연산자의 오른쪽에 있는 값을 왼쪽에 있는 변수에 저장해 준다.

```javascript
var score; // 변수 선언
score = 80; // 값의 할당

var score = 80; // 변수 선언과 값의 할당
```

### 🚨 주의할 점

**변수 선언과 값의 할당은 실행 시점이 다르다.** `변수 선언`은 소스 코드가 순차적으로 실행되는 시점인 `런타임 이전`에 먼저 실행되지만, `값의 할당`은 `런타임`에 실행된다. 잘 모르겠다면 에제를 보고 이해해 보자!

```javascript
console.log(score); // undefined

var score; // ① 변수 선언 - 런타임 이전에 실행
score = 80; // ② 값의 할당 - 런타임에 실행

console.log(score); // 80
```

> 🤔 `score`가 선언되기도 전인데 왜 `console.log(score)`의 출력 결과가 참조 에러가 아닌 `undefined`일까?

바로 **코드를 순차적으로 읽어 내려가는 과정(런타임) 전에 먼저 실행이 되었기 때문이다!** 그래서 값을 할당할 때는 이미 `score`가 `undefined`라는 값을 가지고 있는 상태이고, 이걸 `런타임 과정`에서 80으로 변경(재할당)해 주는 것이다.

변경해 준다고 해서 `undefined`가 존재하던 공간까지 삭제해 버리는 것은 아니다. 새로운 메모리 공간을 확보해서 여기에 `80`을 저장해 주는 것이니 혼동하지 않도록 주의하자!

```javascript
console.log(score); // undefined

var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80
```

변수 선언과 값의 할당을 단축해서 표현해 주면 어떨까? **자바스크립트 엔진은 둘을 두 개의 문(statement)로 나누어 각각 실행해 주기 때문에** 같은 결과가 나타나는 것을 확인할 수 있다!

> 👀 이런 것도 생각해 봐요!

```javascript
console.log(score);

score = 80;
var score;

console.log(score);
```

<details><summary>출력 결과는 무엇일까? 🤔 </summary>
<p>

```
undefined
80
```

</p>
</details>
<br/>

차근차근 생각해 보면 정말 간단하다. 겉으로 보이는 순서 말고, 진짜 실행 순서를 생각해 보자! 변수 선언은 **런타임 이전에,** 값의 할당은 **런타임에** 실행된다. 명심 또 명심하자! ⭐️

## ⭐️ 6. 값의 재할당

### 💬 재할당

**이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당해 주는 것을 말한다.** 쉽게 말하자면 변수에 저장된 값을 다른 값으로 변경해 주는 것이다. 관련 예제 하나를 보자!

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

이쯤에서 다시 `변수`라는 이름이 왜 붙었는지에 대해 생각해 보면, 정말 직관적이다. 언제든지 재할당이 가능하기 때문에 `변수`라는 이름이 붙여진 것이다. 🤩 그런데 만약 값을 재할당할 수 없다면? 이미 저장된 값을 변경할 수 없다면 그건 뭐라고 불러야 좋을까?

> 우리는 이런 걸 **상수(constant)라고** 부르기로 했어요!

`상수`는 **값을 단 한 번만 할당할 수 있는 변수라고** 생각하면 된다. 상수인 변수를 선언하고 싶다면 `const` 키워드를 이용해 선언해 주면 된다.

### 🤔 값의 재할당은 어떻게 이루어질까?

앞서 말했던 것처럼, 값을 변경해 준다고 해서 `80`이 존재하던 공간까지 삭제해 버리는 것은 아니다. 새로운 메모리 공간을 확보해서 여기에 `90`을 저장해 주는 것이다. 그런데 이렇게 되면 `undefined`와 `80`은 어떻게 되는 걸까?

`undefined`와 `80`은 이제 더 이상 아무도 사용하지 않으니 메모리만 덩그러니 차지하고 있는 백수 1과 2다. 그러니 아무도 필요로 하지 않는 이 둘을 누구도 내버려 둘 리가 없는데, 이걸 `가비지 콜렉터`가 내쫓아 준다. 즉, 자동으로 메모리에서 해제해 주는 역할을 수행한다! 🙀 이로써 메모리 누수를 방지할 수 있게 된다.

참고로 자바스크립트는 언어가 메모리 관리 기능을 담당하고 있는 **매니지드 언어이기 때문에** 개발자가 메모리 제어에 관여할 수 없다는 사실 또한 알아 두자!

## 👀 REFERNECE

모던 자바스크립트 Deep Dive 04장 변수
