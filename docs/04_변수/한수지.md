## 변수

### 변수란 무엇인가? 왜 필요한가?

#### 변수의 정의

**변수**는 프로그래밍 언어에서 **데이터를 관리하기 위한 핵심 개념**이다.

> `변수`는 하나의 `값을 저장하기 위해 확보한 메모리 공간 자체` 또는 그 `메모리 공간을 식별하기 위해 붙인 이름`을 말한다. (= **값의 위치를 가리키는 상징적인 이름**)

#### 변수가 필요한 이유

![](https://velog.velcdn.com/images/ninto_2/post/e94c7360-6a8e-4eb2-af46-58560b496931/image.png)

컴퓨터는 메모리를 사용해 데이터를 기억한다.
(1바이트 단위로 데이터를 저장하거나 읽어들임)

`메모리`는 위 그림과 같이, `데이터를 저장할 수 있는 메모리 셀의 집합체`이다.
(셀 하나의 크기는 1바이트(= 8비트))

메모리 주소를 통해 값에 직접 접근하는 것은 매우 위험한 일이다.
(치명적 오류를 발생시킬 가능성이 높음)

> 따라서 **자바스크립트는 직접적인 메모리 제어를 허용하지 않는다.**

![](https://velog.velcdn.com/images/ninto_2/post/e567341a-060f-412a-befd-16fe04b9b3d0/image.png)

그렇기에 위처럼 **변수**를 지원한다.

변수는 컴파일러 또는 인터프리터에 의해 값이 `저장된 메모리 공간의 주소로 치환되어 실행`되기 때문에, `안전하게 값에 접근`할 수 있다.

- **변수 이름**(=변수명) : 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름
- **변수값** : 변수에 저장된 값
- **할당**(= 대입, 저장) : 변수에 값을 저장하는 것
- **참조** : 변수에 저장된 값을 읽어 들이는 것 (주소를 통해 값을 읽는 것)

---

### 식별자

#### 식별자의 정의

> `식별자`는 어떤 **값을 구별해서 식별할 수 있는 고유한 이름**을 말한다. (= 변수 이름도 포함)

![](https://velog.velcdn.com/images/ninto_2/post/c9dc0e05-7975-46d2-baf8-8e4b370314e5/image.png)

**식별자**는 값이 아니라 위 그림처럼, **메모리 주소를 기억**하고 있다.

메모리 상에 존재하는 `어떤 값을 식별할 수 있는 이름은 모두 식별자`라고 부른다.
(변수, 함수, 클래스 등의 이름...)

그렇기에, **네이밍 규칙을 준수**해야 한다. (자바스크립트 코드 컨벤션 참고)
식별자는 선언에 의해 생성된다.

- **선언** : 자바스크립트 엔진에 식별자의 존재를 알림

---

### 변수 선언

#### 변수 선언의 정의

> **변수 선언**이란, `변수를 생성하는 것`을 말한다.

```
// 변수가 선언되는 과정
1. 메모리 공간을 확보하고,
2. 변수 이름과 확보된 메모리 공간의 주소를 연결 해서,
3. 값을 저장할 수 있게 준비하는 것.
```

이 확보된 메모리 공간은 확보가 해제되기 전까지 보호되므로 안전하게 사용가능하다.

(모든 식별자는 **실행 컨텍스트**내에 `키/값`인 객체로 등록되어 관리된다.)

#### 변수 선언 키워드 (var, let, const)

- `var` (함수레벨 스코프를 지원함 <- 심각한 단점, 사용을 지양해야됨)

  - 의도치 않게 전역변수가 선언되어 심각한 부작용이 발생하기도 함
  - 선언단계와 초기화 단계가 동시에 진행됨 (선언과 동시에 undefined로 암묵적인 초기화가 자동수행됨)

- **선언단계** : 변수 이름을 등록해서 변수의 존재를 엔진에 알림
- **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 `암묵적으로 undefined를 할당`해 초기화함

- `let`, `const` : `var`키워드의 한계를 보완하기 위해 나옴. (블록레벨 스코프 지원)

선언하지 않은 식별자에 접근하면, 참조에러가 발생한다.

---

### 변수 선언의 실행 시점과 변수 호이스팅

#### 변수 선언의 실행 시점

선언문은 실행전에 작성한다.

```js
var score1;
let score2;
const score3;

console.log(score1, score2, score3);
```

`var, let, const, function, function\*, class` 키워드를 사용해서 선언하는 **모든 식별자는 호이스팅된다.**

모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

#### 호이스팅이란?

> **호이스팅**이란, **변수 선언문이 코드의 선두로 끌어올려진 것 처럼 동작**하는 자바스크립트 고유의 특징이다.

(변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다.)

변수 선언이 `런타임(소스코드가 한 줄 씩 순차적으로 실행되는 시점)이 아니라, 그 이전 단계에서 먼저 실행되기 때문`이다.

```
// 실행을 위한 준비단계
1. 모든 선언문을 찾아내 실행하고 평가함

// 실행단계
2. 평가 과정이 끝나면 선언문을 제외하고 소스코드를 한 줄 씩 순차적으로 실행함
```

따라서 변수 선언이 어디에 위치하는지 상관없이 변수를 참조할 수 있다.

```js
// 참조에러가 발생해야 하지만, var는 초기화단계가 동시에 진행되므로 undefined가 출력됨
console.log(score); // undefined

var score; // 변수 선언문
```

자바스크립트에서 모든 선언문은 런타임 이전에 실행되는데, `var`키워드는 선언과 동시에 초기화 되버려서 undefined가 출력되며 이는 마치 변수가 위로 끌어져 올라간것처럼 보인다.

---

### 값의 할당

#### 할당 연산자

> 할당연산자 `=`는, 변수에 값을 할당(=대입, 저장) 할때 사용한다.

```js
const score = 80; // 변수 선언과 값의 할당
```

우변의 값을 좌변의 변수에 할당한다.

#### 선언과 할당의 실행시점

- 선언: 런타임 이전에 일어남 (호이스팅)
- 할당: 런타임 때 일어남 (소스코드가 순차적으로 실행되는 시점)

하나의 문장으로 단축해도, 자바스크립트 엔진은 선언과 할당을 2개의 문으로 나누어 각각 실행한다.

![](https://velog.velcdn.com/images/ninto_2/post/8a1edcce-c763-41ed-b08d-55f33c4d86c1/image.png)

위 그림처럼, 값을 할당할때는 `새로운 메모리 공간을 확보`하고 `그곳에 할당 값을 저장`한다.

---

### 값의 재할당

#### 재할당의 정의

> **재할당**이란, 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것을 말한다.

```js
let number = 1;
number = 2; // 값의 재할당

console.log(number);
```

재할당은 변수에 저장된 값을 다른 값으로 변경한다. (그래서 '변'수임)

#### 상수의 정의

> **상수**란, 값을 재할당 할 수 없어서 변수에 저장된 값을 변경할 수 없는 수이다. (한번 정해지면 변하지 않는 값)

이 변수는 값을 바꾸지 말아주세요(재할당x) 할때, `const` 키워드를 사용한다.

`const`키워드는 반드시 상수만을 위해 사용하지는 않는다.

![](https://velog.velcdn.com/images/ninto_2/post/8a1edcce-c763-41ed-b08d-55f33c4d86c1/image.png)

위 그림에서, undefined와 80같은 더이상 불필요한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다.
(언제 해제될지는 예측못함)

- **가비지 콜렉터** : 메모리 공간을 주기적으로 검사해서 더 이상 사용되지 않는 메모리를 해제하는 기능이다.

자바스크립트는 `매니지드 언어`이다. (가바지콜렉터를 사용함)

가비지콜렉터의 존재 유무에 따라, 언매니지드 언어와 매니지드 언어로 분리한다.
