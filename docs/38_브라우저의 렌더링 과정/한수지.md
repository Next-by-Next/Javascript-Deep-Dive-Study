## 38장. ✨ 브라우저의 렌더링 과정

`Node.js`는 구글의 V8 자바스크립트 엔진으로 빌드된 `자바스크립트 런타임 환경`이다.

Node.js의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용할 수 있는 범용 개발 언어가 되었다.

하지만, **자바스크립트가 가장 많이 사용되는 분야**는 역시 **웹 브라우저 환경에서 동작하는 웹페이지/애플리케이션의 클라이언트 사이드**이다.

대부분의 프로그래밍 언어는 운영체제나 가상머신 위에서 실행된다.

> 그렇지만, **웹 애플리케이션의 클라이언트 사이드 자바스크립트**는 **브라우저에서 HTML, CSS와 함께 실행**된다.

따라서 `브라우저의 환경을 고려`할때 `더 효율적인 클라이언트 사이드 자바스크립트 프로그래밍`이 가능해진다.

- `파싱` : 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어들여 실행하기 위해 **텍스트 문서의 문자열을 토큰(Token)으로 분해**하고, **토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료구조인 파스 트리를 생성**하는 일련의 과정

- `렌더링` : **HTML, CSS, 자바스크립트로 작성된 문서를 파싱**하여 **브라우저에 시각적으로 출력**하는 것

🔎 **브라우저의 렌더링 과정**

![](https://velog.velcdn.com/images/ninto_2/post/b11ffc1f-8372-43e8-9d3f-614985bdcc49/image.png)

1. **브라우저**는 HTML, CSS, 자바스크립트, 이미지, 폰트 파일 등 `렌더링에 필요한 리소스를 요청`하고 `서버로부터 응답`받는다.

2. **브라우저의 렌더링 엔진**은 `서버로부터 응답된 HTML, CSS를 파싱`하여 `DOM과 CSSOM을 생성`하고, 이들을 `결합하여 렌더 트리를 생성`한다.

3. **브라우저의 자바스크립트 엔진**은 `서버로부터 응답된 자바스크립트를 파싱`하여 `AST(Abstract Syntax Tree)를 생성하고 바이트코드로 변환하여 실행`한다. 이때 **자바스크립트**는 `DOM API를 통해 DOM이나 CSSOM을 변경`할 수 있고, `변경된 DOM이나 CSSOM은 다시 렌더 트리로 결합`된다.

4. **렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 계산**하고 **브라우저 화면에 HTML 요소를 페인팅**한다.

### 📌 38-1. 요청과 응답

> **브라우저의 핵심 기능**은 `필요한 리소스를 서버에 요청`하고 `서버로부터 응답`받아 `브라우저에 시각적으로 렌더링`하는 것이다.

즉, **렌더링에 필요한 리소스는 모두 서버에 존재**하므로 필요한 리소스를 **서버에 요청하고 서버가 응답한 리소스를 파싱하여 렌더링**하는 것이다.

서버에 요청을 전송하기 위해 브라우저는 주소창을 제공한다.

▼ URI 의 형태 (= 인터넷의 자원을 나타내는 유일한 형태)

![](https://velog.velcdn.com/images/ninto_2/post/aba5944a-5d68-49ed-9ebf-cc1021b4340f/image.png)

🔎 **브라우저 주소창에 URL을 입력하면 생기는 일**

1. 브라우저의 주소창에 URL 입력하고 Enter키를 누른다.
2. URL의 호스트 이름이 DNS를 통해 IP 주소로 변환된다.
3. 이 IP주소를 갖는 서버에게 요청을 전송한다.

▼ 이 과정을 조금 더 상세히 살펴보자면 아래 그림과 같다.

![](https://velog.velcdn.com/images/ninto_2/post/c5e9a885-12c9-48ce-8bc0-0155a6f6bda0/image.png)

1. 사용자가 웹 브라우저의 검색창에 특정 사이트의 주소를 입력
2. 웹 브라우저가 DNS에게 특정 사이트의 (도메인)주소를 요청
3. DNS가 웹 브라우저에게 사이트의 IP주소를 응답
4. 웹 브라우저가 웹 서버에게 IP 주소를 이용하여 HTML 문서를 요청
5. 웹 서버는 바로 웹 페이지를 공급하지 못하고, 웹 애플리케이션 서버와 데이터 베이스에서 웹 페이지 작업을 처리
6. 작업 처리 결과를 웹 서버로 보냄
7. 웹 서버는 웹 브라우저에게 HTML 문서 결과를 응답
8. 웹 브라우저는 화면에 웹 페이지를 출력

만약 브라우저 렌더링 엔진이 HTML을 파싱하는 동안 도중에 외부 리소스를 로드하는 태그를 만나면 HTML파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청한다.

---

### 📌 38-2. HTTP 1.1과 HTTP 2.0

> `HTTP`는 웹에서 `브라우저와 서버가 통신하기 위한 프로토콜(규약)`이다.

🔎 HTTP 1.1과 HTTP 2.0의 차이

- `HTTP/1.1` : 커넥션당 하나의 요청과 응답만 처리한다. (여러개의 요청을 한번에 전송할 수 없고 응답 또한 마찬가지)

  - 동시 전송이 불가능한 구조를 가짐
  - 요청할 리소스의 개수에 비례하여 응답 시간도 증가하는 단점을 가짐

- `HTTP/2.0` : 커넥션당 여러개의 요청과 응답이 가능하다.
  - 다중 요청과 응답이 가능
  - 여러 리소스의 동시 전송이 가능하므로 페이지 로드 속도가 약 50% 빠름

---

### 📌 38-3. HTML 파싱과 DOM 생성

브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트이다.

이 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하기 위해선, 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야한다.

**브라우저 엔진**은 아래와 같은 과정을 통해 **서버로 부터 응답받은 HTML 문서를 파싱**한다.

그리고, **브라우저가 이해할 수 있는 자료구조인 DOM(Document Object Model)을 생성**한다.

> 즉, `DOM은 HTML 문서를 파싱한 결과물`이다.

▼ **브라우저 엔진의 HTML 파싱과 DOM 생성 과정**

![](https://velog.velcdn.com/images/ninto_2/post/3c56e361-f321-48b5-ae46-8455b94b3ba5/image.png)

---

### 📌 38-4. CSS 파싱과 CSSOM 생성

렌더링 엔진은 HTML을 처음부터 한 줄씩 순차적으로 파싱하여 DOM을 생성해나간다.

그 과정에서 CSS를 로드하는 link태그나 style태그를 만나면 DOM생성을 일시 중단하고, 지정된 CSS파일을 서버에 요청하여 HTML과 동일한 파싱 과정을 거치며 해석하여 CSSOM을 생성한다.

> 바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM 생성

이후 CSS파싱이 완료되면 HTML 파싱이 중단된 지점부터 다시 HTML파싱을 하기 시작하여 DOM 생성을 재개한다.

`CSSOM`은 `CSS의 상속을 반영하여 생성`된다.

DOM과 마찬가지의 형태로, 모든 요소의 스타일 요소가 트리 형태로 상속 관계가 반영되어 생성된다.

---

### 📌 38-5. 렌더 트리 생성

렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 CSSOM을 생성한다.

> **DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다.**

- 렌더트리 : 렌더링을 위한 트리 구조의 자료구조

렌더트리는 브라우저 화면에 렌더링되지 않는 노드(ex. meta, script 태그 등)와 CSS에 의해 비표시(ex. display: none)되는 노드들은 포함하지 않는다.

즉, **렌더트리는 브라우저 화면에 렌더링되는 노드만으로 구성**된다.

> 완성된 렌더 트리는 각 HTML요소의 레이아웃(위치와 크기)을 계산하는데 사용되며, 브라우저 화면 픽셀을 렌더링하는 페인팅 처리에 입력된다.

▼ **주요 렌더링 경로** (Critical Rendering Path = CRP) 과정

HTML, CSS, JS 등 작성한 내용을 브라우저 화면의 픽셀로 나타내는 렌더링 과정인 CRP를 살펴보면 아래와 같다.

![](https://velog.velcdn.com/images/ninto_2/post/ab67933c-4d73-49c7-8477-617e09786e6b/image.png)

이 브라우저 렌더링 과정은 반복해서 실행될 수 있다.

다시말해, **레이아웃 계산과 페인팅을 다시 실행하는 리렌더링**은 **비용이 많이 드는 성능에 악영향을 주는 작업**이다.

따라서 **가급적 리렌더링이 빈번하게 발생하지 않도록 주의할 필요**가 있다.

---

### 📌 38-6. 자바스크립트 파싱과 실행

`DOM`은 `HTML 문서를 파싱한 결과물`로서 생성된다.

이 DOM은 **HTML 문서의 구조와 정보**뿐만 아니라 **HTML 요소와 스타일 등을 변경**할 수 있는 **프로그래밍 인터페이스로서 DOM API를 제공**한다.

> **자바스크립트 코드에서 DOM API를 사용하면 이미 생성된 DOM을 동적으로 조작**할 수 있게 된다.

`자바스크립트 파싱과 실행`은 브라우저의 렌더링 엔진이 아닌 `자바스크립트 엔진이 처리`한다.

🔎 **자바스크립트 엔진의 특징**

- `자바스크립트 코드를 파싱`하여 `CPU가 이해할 수 있는 저수준 언어로 변환`하고 `실행`한다.
- 구글 크롬과 Node.js의 V8, 파이어폭스의 SpiderMonkey, 사파리의 JavaScriptCore 등 다양한 종류가 있다.
- 모든 자바스크립트 엔진은 `ECMAScript 사양을 준수`한다.

🔎 **자바스크립트 파싱과 실행 과정**

![](https://velog.velcdn.com/images/ninto_2/post/e685a02e-8a4a-4491-ad1a-882d3a8ee97e/image.png)

> 자바스크립트 엔진이 `코드를 파싱하기 시작`하면, `자바스크립트를 해석`하여 `AST(추상적 구문 트리)를 생성`한다.

- `AST` (추상적 구문 트리) : **토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조**
  - AST는 인터프리터나 컴파일러만이 사용하는 것이 아님
  - AST를 사용하면 TypeScripte, Babel, Prettier 같은 트랜스파일러를 구현할 수 있다.

이 `AST를 기반`으로 `인터프리터가 실행 할 수 있는 중간 코드인 바이트코드를 생성`하여 `실행`한다.

- `토크나이징` (tokenizing) : 단순한 문자열인 **자바스크립트 소스코드를 어휘분석**하여 **문법적 의미를 갖는 코드의 최소 단위인 토큰들로 분해**한다. (= 이 과정을 렉싱이라고 부르기도 하지만 토크나이징과 미묘한 차이가 있음)

- `파싱` (parsing) : 토큰들의 집합을 구문분석하여 AST(추상적 구문 트리)를 생성한다.

- 바이트코드 생성과 실행 : 파싱의 결과물로서 생성된 AST는 **인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환**되고 **인터프리터에 의해 실행**된다.

V8엔진의 경우 자주 사용되는 코드는 터보팬이라 불리는 컴파일러에 의해 최적화된 머신코드로 컴파일되어 성능을 최적화한다.

만약 코드의 사용 빈도가 적어지면 다시 디옵티마이징하기도 한다.

---

### 📌 38-7. 리플로우와 리페인트

자바스크립트 코드에 DOM API를 사용하면 DOM이나 CSSOM을 변경할 수 있다.

이때 **변경된 DOM과 CSSOM은 다시 렌더트리로 결합**되고 **변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정**을 거쳐 **브라우저의 화면에 다시 렌더링**한다.

이를 **리플로우, 리페인트**라고 한다.

![](https://velog.velcdn.com/images/ninto_2/post/4a13beb5-32bb-4660-94fe-76ba911dcc68/image.png)

- `리플로우` : 레이아웃 계산을 다시 하는 것을 말한다.

  - 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행된다.

- `리페인트` : 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것을 말한다.

리플로우와 리페인트가 반드시 순차적으로 동시에 실행되는 것은 아니다.

레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행되기 때문이다.

---

### 📌 38-8. 자바스크립트 파싱에 의한 HTML 파싱 중단

> **렌더링 엔진과 자바스크립트 엔진**은 병렬적으로 파싱을 실행하지 않고, **직렬적으로 파싱을 수행**한다.

▼ HTML 파싱과정에서 블로킹이 발생하는 코드

![](https://velog.velcdn.com/images/ninto_2/post/073f3825-7f5f-4727-9f83-3b3a81c0f457/image.png)

**브라우저는 동기적**으로,

즉 **위에서 아래 방향으로 순차적**으로 **HTML, CSS, JS를 파싱하고 실행**한다.

이때, JS를 파싱하고 실행하는 `script 태그의 위치`에 따라 `HTML 파싱이 블로킹`되어 `DOM 생성이 지연`될 수 있기 때문에 주의가 필요하다.

🔎 **script 태그의 올바른 위치**

> `script 태그를 body 요소의 가장 아래`, 즉 `닫는 body 태그 바로 위에 위치`시켜야한다.

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<!-- HTML 마크업 작성 -->

		<!-- body 요소의 가장 아래 script 태그 작성 -->
		<script src="app.js"></script>
	</body>
</html>
```

이렇게 하면, JS가 실행될 시점에 이미 **렌더링 엔진이 HTML 요소를 모두 파싱하여 DOM 생성을 완료한 후**가 된다.

**DOM이 완성되지 않은 상태에서 JS가 DOM을 조작하는 에러가 발생할 우려가 없어짐**과 동시에, JS가 실행되기 이전에 DOM생성이 완료되어 렌더링되므로 **페이지 로딩 시간이 단축된다는 이점**도 있다.

---

### 📌 38-9. script 태그의 async/defer 어트리뷰트

> **DOM 생성이 중단되는 문제를 근본적으로 해결**하기 위해선, `script 태그에 async와 defer 어트리뷰트를 추가`해준다.

async와 defer 어트리뷰트는 `src 어트리뷰트를 통해 외부 JS 파일을 로드하는 경우에만 사용 가능`하다.
(src 어트리뷰트가 없는 인라인 JS에는 사용불가능)

```html
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Document</title>
	<script async src="ex1.js"></script>
	<script defer src="ex1.js"></script>
</head>
```

async와 defer 어트리뷰트를 사용하면 **HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행**된다.

하지만 이 둘은 자바스크립트의 실행 시점에 차이가 있다.

🔎 **async 어트리뷰트**

![](https://velog.velcdn.com/images/ninto_2/post/b19ede45-e371-4499-b2c7-625cef990551/image.png)

async 어트리뷰트를 사용한 경우, 자바스크립트의 파싱과 실행은 `자바스크립트 파일의 로드가 완료된 직후 진행`되며, 이때 HTML 파싱이 중단된다.

async 어트리뷰트를 script 태그에 지정하면 **태그의 순서와는 상관없이 로드가 완료**된다.

따라서, `순서 보장이 필요한 경우 async 어트리뷰트를 지정하지 않아야`한다.

🔎 **defer 어트리뷰트**

![](https://velog.velcdn.com/images/ninto_2/post/50280bac-0610-4f97-96a6-5c6e7bbd5557/image.png)

defer 어트리뷰트를 사용한 경우, 자바스크립트 파싱과 실행은 `HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후(이때 DOMContentLoaded 이벤트 발생) 진행`된다.

따라서, `DOM 생성이 완료된 이후 실행되어야 할 자바스크립트 유용`하다.
