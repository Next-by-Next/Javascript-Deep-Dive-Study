## 25장. ✨ 클래스

### 📌 25-1. 클래스는 프로토타입의 문법적 설탕인가?

**자바스크립트는 프로토타입 기반 객체지향 언어**이다.
(객체지향 프로그래밍 능력을 가지고 있다.)

- 프로토타입 기반 객체지향 언어: 클래스가 필요없는 객체지향 프로그래밍 언어

ES5이전, 클래스가 등장하기 전에는 자바스크립트에서 클래스가 없이도 생성자 함수나 프로토타입을 통한 객체지향 언어의 상속을 구현할 수 있었다.

하지만 프로토타입 기반 프로그래밍 방식에 혼란을 느낄 수 있으며 어려운 장벽처럼 느끼게 만드는 단점이 있었기에 ES6에서 클래스가 새롭게 등장하게 되었다.

> 클래스는 **생성자 함수보다 엄격**하며 **생성자 함수에서는 제공하지 않는 기능도 제공**한다.

- 클래스를 new 연산자 없이 호출하면 에러가 발생한다.
- 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
- 클래스는 호이스팅이 발생하지 안흔 것 처럼 동작한다. (실제로는 발생함)
- 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 해제할 수 없다.
- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 false이다. (열거되지 않음)

`클래스`를 단순히 프로토타입 기반 객체 생성 패턴의 문법적 설탕이라고 보기보다 `새로운 객체 생성 메커니즘`으로 보는 것이 더 합당하다.

---

### 📌 25-2. 클래스 정의

클래스는 `class` 키워드를 사용하여 정의하며, 클래스 이름은 `파스칼 케이스`를 사용한다.

```js
// 클래스 선언문
class Person {}
```

**클래스는 일급 객체로서 다음과 같은 특징을 갖는다.**

- 무명의 리터럴로 생성할 수 있다. (런타임 이전에 생성 가능)
- 변수나 자료구조에 저장할 수 있다. (객체, 배열등에 저장 가능)
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

클래스가 일급 객체라는 점은, 클래스를 값처럼 사용할 수 있다는 것이다.

**클래스의 기본 구조**

```js
class Person {
	// 필드
	#name;

	// 생성자 : 인스턴스 생성 및 초기화를 담당
	constructor(name) {
		this.#name = name;
	}

	// 메서드 : 프로토타입 메서드와 정적 메서드를 사용할 수 있다.
	// 프로토타입 메서드
	say() {
		console.log(`${this.#name}이 말했다.`);
	}

	// 정적 메서드
	static sayHi() {
		console.log("hi");
	}
}
```

---

### 📌 25-3. 클래스 호이스팅

**클래스는 함수로 평가**된다.

```js
class Person {} // type: function
```

클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 **소스코드 평가 과정(런타임 이전에 평가)에서 함수 객체를 생성**한다.

이때, `클래스가 평가되어 생성된 함수 객체`는 `생성자 함수`이다.

생성자 함수(constructor)는 생성자 함수로서 호출할 수 있는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

클래스는 호이스팅이 발생하지 않는 것 처럼 보이지만, <br>
**클래스 선언문 또한 호이스팅이 발생**한다.

(클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 보임)

단, `클래스는 let, const 키워드로 선언한 변수처럼 호이스팅`된다.

---

### 📌 25-4. 인스턴스 생성

> 클래스는 **생성자 함수**이며 `new`연산자와 함께 호출되어 **인스턴스를 생성**한다.

```js
class Person {}

// 인스턴스 생성
const me = new Person();
const you = new Person();
```

**클래스는 인스턴스를 생성하는 것이 유일한 존재 이유**이다.

반드시 new 연산자와 함께 호출해야 한다.

---

### 📌 25-5. 메서드

#### 🔎 constructor

> `constructor`는 `인스턴스를 생성하고 초기화`하기 위한 특수한 메서드이다.

constructor의 이름은 변경할 수 없다.

```js
class Person {
	constructor(name, age) {
		// 인스턴스 생성 및 초기화
		this.name = name;
		this.age = age;
	}

	say() {
		console.log(`이름은 ${this.name} 나이는 ${this.age}이다.`);
	}
}

const foo = new Person("Foo", 20);
foo.say(); // 이름은 Foo 나이는 20이다.
```

constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부이다.

> 즉, **클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성**된다.

추가적으로 constructor 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손하는 것이다.
(constructor 내부에는 this의 값만을 사용하자.)

또한 **return문은 반드시 생략**해야 한다.

#### 🔎 프로토타입 메서드

> `클래스 몸체에서 정의`한 메서드는 `기본적으로 프로토타입 메서드`가 된다.

```js
class Person {
	// 프로토타입 메서드들
	say() {
    ...
  }

	eat() {
    ...
  }

	study() {
    ...
  }
}

// 인스턴스는 프로토타입 메서드를 상속받아 사용할 수 있다.
const foo = new Person();
foo.say();
foo.eat();
foo.study();
```

위처럼, **클래스는 프로토타입 기반의 객체 생성 메커니즘**이다.

#### 🔎 정적 메서드

> 정적 메서드는 `인스턴스를 생성하지 않아도 호출할 수 있는 메서드`이다.

클래스에서는 메서드에 `static` 키워드를 붙이면 정적 메서드(클래스 메서드)가 된다.

```js
class Validator {
  static validate () {
    ...
  }
}

// 인스턴스를 생성하지 않아도 호출가능 (클래스로 호출해야함)-
Validator.validate();
```

#### 🔎 정적 메서드와 프로토타입 메서드의 차이

- 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 **프로토타입 체인이 다르다.**
- **정적 메서드는 클래스로 호출**하고 **프로토타입 메서드는 인스턴스로 호출**한다.
- 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, **프로토타입 메서드는 인스턴스 프로퍼티를 참조**할 수 있다.

#### 🔎 클래스에서 정의한 메서드의 특징

- function 키워드를 생략한 메서드 축약 표현을 사용한다.
- 클래스에 메서드를 정의할 때 콤마가 필요없다.
- 암묵적으로 strict mode로 실행된다.
- for...in 문이나 Object.keys 메서드 등으로 열거할 수 없다.
- 내부 메서드 `[[Construct]]`를 갖지 않는 non-constructor이다.

---

### 📌 25-6. 클래스의 인스턴스 생성 과정

**클래스의 인스턴스가 생성되는 과정**은 아래와 같다.

1. 인스턴스 생성과 this 바인딩
2. 인스턴스 초기화
3. 인스턴스 반환

```js
class Person {
	// 2. this에 바인딩 되어 있는 인스턴스를 초기화시킴
	constructor(name) {
		this.name = name;
	}

	sayName() {
		console.log(this.name);
	}
}

// 1. 인스턴스 생성 - new 연산자와 함께 클래스를 호출하면 암묵적으로 빈 객체가 생성(클래스가 생성한 인스턴스)
// 3. 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환됨
const foo = new Person("Foo");

foo.sayName();
```

---

### 📌 25-7. 프로퍼티

#### 🔎 인스턴스 프로퍼티

인스턴스 프로퍼티는 constructor 내부에서 정의해야 한다.

> **constructor 내부에서 this에 추가한 프로퍼티**는 언제나 **클래스가 생성한 인스턴스의 프로퍼티**가 된다.

```js
class Person {
	constructor(name) {
		// 인스턴스 프로퍼티 - public 프로퍼티
		this.name = name;
	}
}

const foo = new Person("Foo");

console.log(foo.name); // Foo
```

기본적으로 **인스턴스의 프로퍼티는 언제나 public하다.**

#### 🔎 접근자 프로퍼티

접근자 프로퍼티는 클래스에서도 사용할 수 있다. (get, set)

`접근자 프로퍼티`는 **자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 사용**하는 접근자 함수, `getter와 setter 함수로 구성`되어 있다.

클래스의 메서드는 기본적으로 프로토타입 메서드이기 때문에 **클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티**가 된다.

<br>

#### 🔎 클래스 필드 정의 제안

> **클래스 필드(필드 또는 멤버)**는 클래스 기반 객체지향 언어에서 **클래스가 생성할 인스턴스의 프로퍼티**를 가리키는 용어이다.

자바스크립트 클래스 몸체에는 메서드만 선언할 수 있다.
만약 **클래스 몸체에서 클래스 필드를 정의하는 경우 this에 클래스 필드를 바인딩해서는 안된다.**

기본적으로 클래스 필드에 초기값을 할당하지 않으면 undefined를 갖는다.

인스턴스를 생성할 때 **외부의 초기값으로 클래스 필드를 초기화**해야 할 필요가 있다면 **constructor 내부에서 클래스 필드를 초기화** 해야 한다.

```js
class Person {
	// 클래스 필드 - this를 사용할 수 없다.
	name; // undefined

	constructor(name) {
		// 외부의 초기값으로 클래스 필드를 초기화
		this.name = name;
	}
}
```

만약 초기값을 외부에서 전달 받을 필요가 없다면 클래스 필드에서 바로 초기화를 할 수 있다.

```js
class Person {
	// 클래스 필드
	name = "Foo";

	say() {
		console.log(this.name);
	}
}
```

<br>

#### 🔎 private 필드 정의 제안

private 필드는 캡슐화와 정보 은닉에 도움을 준다.

`private 필드`는 반드시 `클래스 몸체에 정의`해야 하며, 선두에 `#`을 붙인다.

```js
class Person {
	// private 필드
	#name;

	constructor(name) {
		// 참조를 할 경우에도 #을 붙여야 한다.
		this.#name = name;
	}

	sayName() {
		console.log(this.#name);
	}
}
```

**public과 private의 접근 비교**

|         접근 가능성         | public | private |
| :-------------------------: | :----: | :-----: |
|         클래스 내부         |  가능  |  가능   |
|      자식 클래스 내부       |  가능  | 불가능  |
| 클래스 인스턴스를 통한 접근 |  가능  | 불가능  |

<br>

#### 🔎 static 필드 정의 제안

클래스에는 static 키워드를 사용하여 정적 메서드를 정의할 수 있다.

하지만, static 키워드를 사용하여 정적 필드를 정의할 수는 없었다.

2021년 새로운 표준사양에서는 static public/private 필드 정의가 제안되었다.

```js
class Match {
	// static public 필드 정의
	static PI = 22 / 7;

	// static private 필드 정의
	static #num = 10;

	// static 메서드
	static increment() {
		return ++Match.#num;
	}
}
```

---
