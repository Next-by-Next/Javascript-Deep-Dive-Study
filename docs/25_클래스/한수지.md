## 25장. ✨ 클래스

### 📌 25-1. 클래스는 프로토타입의 문법적 설탕인가?

**자바스크립트는 프로토타입 기반 객체지향 언어**이다.
(객체지향 프로그래밍 능력을 가지고 있다.)

- 프로토타입 기반 객체지향 언어: 클래스가 필요없는 객체지향 프로그래밍 언어

ES5이전, 클래스가 등장하기 전에는 자바스크립트에서 클래스가 없이도 생성자 함수나 프로토타입을 통한 객체지향 언어의 상속을 구현할 수 있었다.

하지만 프로토타입 기반 프로그래밍 방식에 혼란을 느낄 수 있으며 어려운 장벽처럼 느끼게 만드는 단점이 있었기에 ES6에서 클래스가 새롭게 등장하게 되었다.

> 클래스는 **생성자 함수보다 엄격**하며 **생성자 함수에서는 제공하지 않는 기능도 제공**한다.

- 클래스를 new 연산자 없이 호출하면 에러가 발생한다.
- 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다.
- 클래스는 호이스팅이 발생하지 안흔 것 처럼 동작한다. (실제로는 발생함)
- 클래스 내의 모든 코드에는 암묵적으로 strict mode가 지정되어 실행되며 해제할 수 없다.
- 클래스의 constructor, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 false이다. (열거되지 않음)

`클래스`를 단순히 프로토타입 기반 객체 생성 패턴의 문법적 설탕이라고 보기보다 `새로운 객체 생성 메커니즘`으로 보는 것이 더 합당하다.

---

### 📌 25-2. 클래스 정의

클래스는 `class` 키워드를 사용하여 정의하며, 클래스 이름은 `파스칼 케이스`를 사용한다.

```js
// 클래스 선언문
class Person {}
```

**클래스는 일급 객체로서 다음과 같은 특징을 갖는다.**

- 무명의 리터럴로 생성할 수 있다. (런타임 이전에 생성 가능)
- 변수나 자료구조에 저장할 수 있다. (객체, 배열등에 저장 가능)
- 함수의 매개변수에 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

클래스가 일급 객체라는 점은, 클래스를 값처럼 사용할 수 있다는 것이다.

**클래스의 기본 구조**

```js
class Person {
	// 필드
	#name;

	// 생성자 : 인스턴스 생성 및 초기화를 담당
	constructor(name) {
		this.#name = name;
	}

	// 메서드 : 프로토타입 메서드와 정적 메서드를 사용할 수 있다.
	// 프로토타입 메서드
	say() {
		console.log(`${this.#name}이 말했다.`);
	}

	// 정적 메서드
	static sayHi() {
		console.log("hi");
	}
}
```

---

### 📌 25-3. 클래스 호이스팅

**클래스는 함수로 평가**된다.

```js
class Person {} // type: function
```

클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 **소스코드 평가 과정(런타임 이전에 평가)에서 함수 객체를 생성**한다.

이때, `클래스가 평가되어 생성된 함수 객체`는 `생성자 함수`이다.

생성자 함수(constructor)는 생성자 함수로서 호출할 수 있는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.

클래스는 호이스팅이 발생하지 않는 것 처럼 보이지만, <br>
**클래스 선언문 또한 호이스팅이 발생**한다.

(클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 보임)

단, `클래스는 let, const 키워드로 선언한 변수처럼 호이스팅`된다.

---

### 📌 25-4. 인스턴스 생성

> 클래스는 **생성자 함수**이며 `new`연산자와 함께 호출되어 **인스턴스를 생성**한다.

```js
class Person {}

// 인스턴스 생성
const me = new Person();
const you = new Person();
```

**클래스는 인스턴스를 생성하는 것이 유일한 존재 이유**이다.

반드시 new 연산자와 함께 호출해야 한다.

---

### 📌 25-5. 메서드

#### 🔎 constructor

> `constructor`는 `인스턴스를 생성하고 초기화`하기 위한 특수한 메서드이다.

constructor의 이름은 변경할 수 없다.

```js
class Person {
	constructor(name, age) {
		// 인스턴스 생성 및 초기화
		this.name = name;
		this.age = age;
	}

	say() {
		console.log(`이름은 ${this.name} 나이는 ${this.age}이다.`);
	}
}

const foo = new Person("Foo", 20);
foo.say(); // 이름은 Foo 나이는 20이다.
```

constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부이다.

> 즉, **클래스 정의가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성**된다.

추가적으로 constructor 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손하는 것이다.
(constructor 내부에는 this의 값만을 사용하자.)

또한 **return문은 반드시 생략**해야 한다.

#### 🔎 프로토타입 메서드

> `클래스 몸체에서 정의`한 메서드는 `기본적으로 프로토타입 메서드`가 된다.

```js
class Person {
	// 프로토타입 메서드들
	say() {
    ...
  }

	eat() {
    ...
  }

	study() {
    ...
  }
}

// 인스턴스는 프로토타입 메서드를 상속받아 사용할 수 있다.
const foo = new Person();
foo.say();
foo.eat();
foo.study();
```

위처럼, **클래스는 프로토타입 기반의 객체 생성 메커니즘**이다.

#### 🔎 정적 메서드

> 정적 메서드는 `인스턴스를 생성하지 않아도 호출할 수 있는 메서드`이다.

클래스에서는 메서드에 `static` 키워드를 붙이면 정적 메서드(클래스 메서드)가 된다.

```js
class Validator {
  static validate () {
    ...
  }
}

// 인스턴스를 생성하지 않아도 호출가능 (클래스로 호출해야함)-
Validator.validate();
```

#### 🔎 정적 메서드와 프로토타입 메서드의 차이

- 정적 메서드와 프로토타입 메서드는 자신이 속해 있는 **프로토타입 체인이 다르다.**
- **정적 메서드는 클래스로 호출**하고 **프로토타입 메서드는 인스턴스로 호출**한다.
- 정적 메서드는 인스턴스 프로퍼티를 참조할 수 없지만, **프로토타입 메서드는 인스턴스 프로퍼티를 참조**할 수 있다.

#### 🔎 클래스에서 정의한 메서드의 특징

- function 키워드를 생략한 메서드 축약 표현을 사용한다.
- 클래스에 메서드를 정의할 때 콤마가 필요없다.
- 암묵적으로 strict mode로 실행된다.
- for...in 문이나 Object.keys 메서드 등으로 열거할 수 없다.
- 내부 메서드 `[[Construct]]`를 갖지 않는 non-constructor이다.

---
