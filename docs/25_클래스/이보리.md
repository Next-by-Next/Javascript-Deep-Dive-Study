# 25장 클래스

## 📂 25.1 클래스는 프로토타입의 문법적 설탕인가?

- 자바스크립트는 프로토타입 기반<sup>prototype based</sup> 객체지향언어다.
- 프로토타입 기반 객체지향 언어는 클래스가 필요없는<sup>class free</sup> 객체 지향 프로그래밍이다.
- ES5에서는 클래스 없이도 생성자 함수와 프로토타입을 통해 객체지향 언어의 상속을 구현할 수 있다.

#### 클래스

- ES6에 도입
- 클래스는 함수이며 기존 프로토타입 기반 패턴을 클래스 기반 패터ㅗㄴ처럼 사용할 수 있도록 하는 문법적 설탕<sup>syntactic sugar</sup>이라고 볼 수 있다.
- 단, 클래스와 생성자 함수는 모두 프로토타입 기반의 인스턴스를 생성하지만 동작에 차이가 있다.

#### 클래스와 생성자 함수의 차이점

1. 클래스를 `new` 연산자 없이 호출하면 에러가 발생한다.
   ⇒ 생성자 함수를 `new` 연산자 없이 호출하면 일반 함수로서 호출된다.
2. 클래스는 상속을 지원하는 `extends`와 super 키워드를 제공한다.
   ⇒ 생성자 함수는 `extends`와 super 키워드를 제공하지 않는다.
3. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다.
   ⇒ 함수 선언문으로 정의된 생성자 함수는 함수 호이스팅이, 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.
4. 클래스 내의 모든 코드에는 암묵적으로 `strict mode`가 지정되어 실행되며 `strict mode`를 해제할 수 없다.
   ⇒ 생성자 함수는 암묵적으로 `strict mode`가 지정되지 않는다.
5. 클래스의 `constructor`, 프로토타입 메서드, 정적 메서드는 모두 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 `false`다.

클래스는 생성자 함수 기반의 객체 생성 박식보다 견고하고 명료하다.
따라서 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 **새로운 객체 생성 매커니즘**으로 보는 것이 좀 더 합당하다.

## 📂 25.2 클래스 정의

- `class` 키워드를 사용하여 정의
- 클래스 이름은 파스칼 케이스를 사용하는 것이 일반적

```javascript
//  클래스 선언문
class Person {}
```

- 클래스도 표현식으로 정의할 수 있다.

```javascript
// 익명 클래스 표현식
const Person = class {};

// 기명 클래스 표현식
const Person = class MyClass {};
```

⇒ 클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 **일급 객체**라는 것을 의미

#### 클래스가 일급 객체로서 가지는 특징

- 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.
- 변수나 자료구조(객체, 배열 등)에 저장할 수 있다.
- 함수의 매개변수에게 전달할 수 있다.
- 함수의 반환값으로 사용할 수 있다.

⇒ **클래스는 함수다. 따라서 클래스는 값처럼 사용할 수 있는 일급 객체다.**

- 클래스 몸체에는 0개 이상의 메서드만 정의할 수 있다.
- 클래스 몸체에서 정의할 수 있는 메서드
  - `constructor`(생성자)
  - 프로토타입 메서드
  - 정적 메서드

```javascript
// 클래스 선언문
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name; // name 프로퍼티는 public하다.
  }

  // 프로토타입 메서드
  sayHi() {
    console.log(`Hi! My name is ${this.name}`);
  }

  // 정적 메서드
  static sayHello() {
    console.log('Hello');
  }
}

// 인스턴스 생성
const me = new Person('Lee');

// 인스턴스의 프로퍼티 참조
console.log(me.name); // Lee
// 프로토타입 메서드 호출
me.sayHi(); // Hi! My name is Lee
// 정적 메서드 호출
Person.sayHello(); // Hello
```

- 클래스와 생성자 함수의 정의 방식은 형태적인 면에서 매우 유사하다.

```javascript
// 위의 클래스 코드와 비교
var Person = (function () {
  // 생성자 함수
  function Person(name) {
    this.name = name;
  }

  // 프로토타입 메서드
  Person.prototype.sayHi = function () {
    console.log('Hi! My name is ' + this.name);
  };

  // 정적 메서드
  Person.sayHello = function () {
    console.log('Hello!');
  };

  // 생성자 함수 반환
  return Person;
})();
```

## 📂 25.3 클래스 호이스팅

#### 클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 소스코드 평가과정, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다.

- 이때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함주, 즉 `constructor`다.
- 생성자 함수로서 호출할 수 있는 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
  ⇒ 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하기 떄문

```javascript
// 클래스 선언문
class Person {}

console.log(typeof Person); // function
```

#### 클래스는 클래스 정의 이전에 참조할 수 없다.

```javascript
console.log(Person);
// ReferenceError: Cannot access 'Person' before initialization

// 클래스 선언문
class Person {}
```

#### 클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다.

- 클래스 선언문은 `let`, `const` 키워드로 선언한 변수처럼 호이스팅이 발생한다.
- 따라서 클래스 선언문 이전에 **일시적 사각지대<sup>Temporal Dead Zone; TDZ</sup>** 에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작한다.

```javascript
const Person = '';

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
  console.log(Person);
  // ReferenceError: Cannot access 'Person' before initialization

  // 클래스 선언문
  class Person {}
}
```

⇒ `var`, `let`, `const`, `function`, `fucntion*`, `class` 키워드를 사용하여 선언된 모든 식별자는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문

## 📂 25.4 인스턴스 생성

#### 클래스는 생성자 함수이며 `new` 연산자와 함께 호출되어 인스턴스를 생성한다.

```javascript
class Person {}

// 인스턴스 생성
const me = new Person();
console.log(me); // Person {}
```

#### 클래스는 new 연산자와 함께 호출해야 한다.

- 함수 : `new` 연산자의 사용 여부에 따라 일반 함수로 호출되거나 인스턴스 생성을 위한 생성자 함수로 호출
- 클래스 : 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 `new` 연산자와 함께 호출해야 한다.

```javascript
class Person {}

// 클래스를 new 연산자 없이 호출하면 타입 에러 발생
const me = Person();
// TypeError: Class constructor Person cannot be invoked without 'new'
```

#### 기명 클래스 표현식의 클래스 이름을 사용해 인스턴스를 생성하면 에러가 발생한다.

- 클래스 표현식으로 정의된 클래스의 경우 다음 예제와 같이 클래스를 가리키는 식별자(`Person`)를 사용해 인스턴스를 생성하지 않고 기명 클래스 표현식의 클래스 이름(`MyClass`)을 사용해 인스턴스를 생성하면 에러가 발생한다.
- 기명 함수 표현식과 마찬가지로 클래스 표현식에서 사용한 클래스 이름은 외부 코드에서 접근 불가능하다.

```javascript
const Person1 = class MyClass {};

// 함수 표현식과 같이 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.
const me = new Person1();

// 클래스 이름 MyClass는 클래스 몸체 내부에서만 유효한 식별자
console.log(MyClass); // ReferenceError: MyClass is not defined

const you = new MyClass(); // ReferenceError: MyClass is not defined
```
