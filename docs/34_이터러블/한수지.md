## 34장. ✨ 이터러블

### 📌 34-1. 이터레이션 프로토콜

> ES6에서 도입된 `이터레이션 프로토콜`은 **순회 가능한 데이터 컬렉션(자료구조)**를 만들기 위해 ECMAScript 사양에 정의하여 미리 약속한 규칙이다.

ES6에서는 **순회 가능한 데이터 컬렉션**을 이터레이션 프로토콜을 준수하는 **이터러블로 통일**하였다.

이터러블은 `for ... of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용`할 수 있도록 일원화하였다.

- 🔎 이터러블: 이터러블 프로토콜을 준수한 객체

  - for ... of문, 스프레드 문법, 배열 디스트럭처링 할당의 대상으로 사용 가능하다.

- 🔎 이터레이터: 이터레이터 프로토콜을 준수한 객체,

  - `이터러블의 요소를 탐색`하기 위한 포인터 역할을 한다.
  - 이터러블의 Symbol.iterator 메서드가 반환한 이터레이터는 `next 메서드`를 갖는다.
  - next 메서드를 호출하면 이터러블을 순차적으로 순회하며 `이터레이터 리절트 객체를 반환`한다.

---

### 📌 34-2. 빌트인 이터러블

자바스크립트는 `이터레이션 프로토콜을 준수`한 객체인 `빌트인 이터러블을 제공`한다.

| 빌트인 이터러블 | Symbol.iterator 메서드                                                                 |
| :-------------- | :------------------------------------------------------------------------------------- |
| Array           | `Array.prototype[Symbol.iterator]`                                                     |
| String          | `String.prototype[Symbol.iterator]`                                                    |
| Map             | `Map.prototype[Symbol.iterator]`                                                       |
| Set             | `Set.prototype[Symbol.iterator]`                                                       |
| TypedArray      | `TypedArray.prototype[Symbol.iterator]`                                                |
| arguments       | `arguments.prototype[Symbol.iterator]`                                                 |
| DOM 컬렉션      | `NodeList.prototype[Symbol.iterator]` <br> `HTMLCollection.prototype[Symbol.iterator]` |

---

### 📌 34-3. for ... of 문

> `for ... of 문`은 이터러블을 순회하면서 이터러블의 요소를 변수에 할당한다.

```js
// for of문의 문법

for (변수선언문 of 이터러블) {
    ...
}
```

`for ... of 문`의 구조 자체는 `for ... in` 문과 매우 유사하다.

- `for ... of`문 : 내부적으로 이터레이터의 next를 호출하여 이터러블을 순회하며, next메서드가 반환한 이터레이터 리절트 객체의 value 프로퍼티 값을 for ... of 문의 변수에 할당한다.

- `for ... in`문 : 객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 `[[Enumerable]]`의 값이 true인 프로퍼티를 순회하며 열거한다. (키가 심벌인 프로퍼티는 열거하지 않음)

---

### 📌 34-4. 이터러블과 유사 배열 객체

- 유사 배열 객체: 배열처럼 **인덱스**로 프로퍼티 값에 접근할 수 있고, **length 프로퍼티를 갖는 객체**
  - for 문으로 순회 가능하다.
  - 인덱스로 프로퍼티 값에 접근할 수 있다.

유사 배열 객체는 이터러블이 아닌 일반 객체이다. (= 유사 배열 객체에는 `Symbol.iterator`메서드가 없다.)

따라서, 유사 배열 객체는 for ... of 문으로 순회할 수 없다.

배열은 ES6에서 이터러블이 도입되면서 `Symbol.iterator` 메서드를 구현하여 이터러블이 되었다.

---

### 📌 34-5. 이터레이션 프로토콜의 필요성

> ES6에서는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜을 준수하는 **이터러블로 통일**하여 **for ... of문, 스프레드 문법, 배열 디스트럭처링 할당 대상으로 사용할 수 있도록 일원화**하였다.

이터레이션 프로토콜은 다양한 데이터 공급자가 하나의 순회 방식을 갖도록 규정하여,
데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 `데이터 소비자와 테이터 공급자를 연결하는 인터페이스의 역할을 한다.`

---

### 📌 34-6. 사용자 정의 이터러블

#### 🔎 사용자 정의 이터러블 구현

이터레이션 프로토콜을 준수하지 않는 일반 객체도 아래와 같이 `이터레이션 프로토콜을 준수`하도록 구현하면 `사용자 정의 이터러블`이 된다.

- Symbol.iterator 메서드를 구현
- Symbol.iterator 메서드가 next 메서드를 갖는 이터레이터를 반환
- 이터레이터의 next메서드는 done과 value 프로퍼티를 가지는 이터레이터 리절트 객체를 반환

```js
// 사용자 정의 이터러블 예시 - 피보나치 수열 구현
const fibonacci = {
  [Symbol.iterator]() {
    let [pre, cur] = [0, 1];
    const max = 10;

    return {
      next() {
        [pre, cur] = [cur, pre + cur];

        return {
            value: cur,
            done: cur >= max;
          }
      }
    }
  }
};

// 이터러블인 fibonacci 객체를 순회할 때마다 next 메서드가 호출됨
for (const num of fibonacci) {
  console.log(num); // 1 2 3 5 8
}
```
