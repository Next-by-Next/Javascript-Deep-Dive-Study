# 06. 데이터 타입

자바스크립트의 모든 값은 데이터 타입을 갖고, ES6는 7개의 테이터 타입을 제공한다.
데이터 타입은 원시 타입과 참조 타입으로 나누어 진다.

## 6.1 숫자 타입

정수, 실수 등과 같은 다양한 종류의 숫자 타입을 제공하는 C나 JAVA와 달리 JavaScript는 모든 숫자를 실수로 처리한다.

### 숫자 타입의 특별한 값

```jsx
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * "String"); // NaN
```

## 6.2 문자열 타입

- 텍스트 데이터를 나타내는데 사용됨.
- 0개 이상의 16비트 유니코드 문자(UTF-16)의 집합으로 전 세계 대부분 문자 표현 가능하다.
- 따옴표로 감싸 나타냄(키워드나 식별자 같은 토큰과 구분하기 위함), 일반적으로는 작은 따옴표를 사용한다.

## 6.3 템플릿 리터럴

- ES6부터 추가되었으며, 런타임에서 일반 문자열로 치환된다.
- 백틱(``) 사용해 표현
- 멀티라인, 표현식 삽입, 태그드 템플릿 등의 기능을 제공한다.

### 멀티라인 문자열

- 문자열 내에서는 줄바꿈 허용 안됨
- 백슬래쉬(\)로 시작하는 이스케이프 시퀸스를 사용해야함 (e.g. \n, \”)
- 템플릿 리터럴 내에서는 이스케이프 시퀸스를 사용하지 않아도 줄바꿈 허용됨

```jsx
var template = `<ul>\n\t<li><a href="#">Home</a></li>\n</ul>`;

console.log(template);
```

```jsx
var template = `<ul>
	<li><a href="#">Home</a></li>
</ul>`;

console.log(template);
```

### 표현식 삽입

- ${ }으로 표현식 삽입 가능

```jsx
var first = "Ung-mo";
var last = "Lee";

console.log("My name is" + first + " " + last + "."); // My name is Ung-mo Lee
console.log(`My name is ${first} ${last}.`); // My name is Ung-mo Lee.
```

## 6.4 불리언 타입

- true, false 만 존재
- 조건문에 자주 사용됨

## 6.5 undefined 타입

- undefined가 유일
- var 키워드로 선언한 변수는 암묵적으로 undefined로 초기화됨(메모리 공간 할당이 이뤄질 때까지 빈 상태, 쓰레기 값으로 내버려 두지 않음)
- undefined 타입의 값은 undefined가 유일하므로 변수에 undefined를 할당하는 것은 변수를 초기화하는 것과 같음

### undefined 타입의 주의점

- 개발자가 의도적으로 undefined를 할당하지 않는 것을 권장
- 변수에 값이 없다는 것을 명시하고 싶을 때는 null 할당

### 선언과 정의

- 자바스크립트는 변수를 선언하면서 암묵적으로 정의가 이루어지기 때문에 구분이 모호함
- 변수는 “선언한다”라고 표현, 함수는 “정의한다”라고 표현

## 6.6 null 타입

- null이 유일
- 함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 함
  - document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 null을 반환함

## 6.7 심벌 타입

- 변경 불가능한 원시 타입, 다른 값과 중복되지 않는 유일무이한 값이다.
- 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들 때 사용한다.
- 다른 원시 값이 리터럴을 통해 생성되는 것과 달리 Symbol()를 호출해 생성한다.
- 생성되는 심벌 값은 외부에 노출되지 않고, 유일무이한 값이다.

```
let a = Symbol('key');
let b = Symbol('key');
const obj = {};
obj[a] = 'valueA';
obj[b] = 'valueB';
console.log(obj[a]);  // valueA
console.log(obj[b]);  // valueB
```

위 코드에서 a, b가 같은 값으로 보이지만 심벌 타입으로 유일무이한 값이므로 a === b의 연산 결과값은 false이며, obj[a], obj[b]도 서로 다른 것을 저장한다.

## 6.8 참조 타입

- 원시값을 제외한 모든 것이 객체이며 참조 타입이다.

## 6.9 데이터 타입의 필요성

### 데이터 타입에 의한 메모리 공간의 확보와 참조

- 값을 저장할 때 확보해야 하는 메모리 공간의 크기 결정
- 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기 결정
- 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정

값은 메모리에 저장하고 참조할 수 있어야 한다.

이 때, 먼저 확보해야 할 메모리 공간의 크기를 결정해야 낭비와 손실 없이 값을 저장할 수 있다.

```
let score = 100;
```

위 코드에서 숫자 값 100을 저장하기 위해 메모리 공간을 확보한 후, 그 메모리에 숫자 값 100을 2진수로 저장한다.

이 때, 얼마 만큼의 메모리 공간을 확보할 지 알아야 하는데, Javascript 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보한다.

Javascript 엔진은 레터럴 100을 숫자 타입의 값으로 해석하고 이를 저장하기 위해 8바이트의 메모리 공간을 확보하고 100을 2진수로 저장한다.

반대로, 값을 참조할 때는 식별자 score를 통해 메모리 공간의 주소(정확히는 선두 메모리 셀의 주소)를 찾아갈 수 있다.

이 때, 값을 참조하려면 한 번에 읽어 들여야 할 메모리 공간의 크기(메모리 셀의 개수, 바이트 수)를 알아야 값의 훼손 없이 읽어들일 수 있다.

마찬가지로, Javascript 엔진은 score 변수의 데이터 타입을 통해 읽어 들일 메모리 공간의 크기를 알아낸다.

> 심벌 테이블? 컴파일러는 심벌 테이블이라는 자료구조를 통해 식별자를 키로 바인딩된 값의 메모리 주소, 데이터 타입, 스코프(유효 범위) 등을 관리한다.

#### 6.9.2 데이터 타입에 의한 값의 해석

메모리에서 읽어 들인 2진수는 어떻게 해석할까?

0100 0001을 숫자로 해석하면 65, 문자열로 해석하면 'A'이다.

따라서, 어떻게 해석할 지를 정할 때 해당 변수의 데이터 타입을 따라 정하게 된다.

## 6.10 동적 타이핑

#### 6.10.1 동적 타입 언어와 정적 타입 언어

C++, Java 같은 정적 타입<sup>static/strong type</sup> 언어는 변수를 선언할 때 데이터 타입을 함께 선언해야 한다. <i>Ex) int age;</i>

이를 명시적 타입 선언<sup>explicit type declaration</sup>이라 한다.

정적 타입 언어는 변수의 타입을 변경할 수 없어, 해당 데이터 타입에 맞는 값만 할당할 수 있다.

컴파일 시점에 타입 체크<sup>type check</sup>를 수행하여 불통 시에 에러를 발생시키고 프로그램 실행을 막는다.

Javscript는 변수를 선언할 때 데이터 타입을 선언하지 않는다.

미리 선언한 데이터 타입의 값만 할당할 수 있는 것이 아니라는 점에서 정적 타입 언어와 다르며, 아래 코드 예시처럼 어떠한 데이터 타입의 값이라도 얼마든지 재할당할 수 있다.
| foo 값 | typeof(데이터 타입) foo |
|--------|----------------------|
| | undefined |
| 3 | number |
| 'taehwan' | string |
| true | boolean |
| null | object |
| Symbol() | symbol |
| {} | object |
| [] | object |
| function(){} | function |

따라서, Javscript의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론<sup>type inference</sup>)된다.

또, 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다.

이는 동적 타입<sup>dynamic/weak type</sup> 언어라 한다.

변수는 타입을 갖지 않지만, 변수에 할당된 값은 타입을 갖고, 이 값에 의해 변수의 타입이 동적으로 결정되는 것이다. <i>변수는 값에 묶여 있는 값에 대한 별명이라 생각하자.</i>

#### 6.10.2 동적 타입 언어와 변수

### 동적 타입 언어의 문제점

- 변수의 값이 언제든지 변경될 수 있어 복잡한 프로그램에서는 변수 값 추적이 어려울 수 있다.
- 값이 변하기 때문에 변수의 타입 역시 동적으로 변하여 변수의 값을 확인하기 전에는 해당 변수의 데이터 타입을 확신할 수 없다. (심지어 Javscript 엔진은 암묵적으로 타입이 자동 변환하기까지 한다.)

따라서, 이러한 문제점들을 방지하기 위해 주의사항을 따라야 한다.

- 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다.
- 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다.
- 전역 변수는 최대한 사용하지 않는다.
- 변수(let, var)보다는 상수(const)를 사용해 값의 변경을 억제한다.
- 변수, 함수, 클래스 등의 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다.

## 👀 되돌아보기

- <b>숫자 타입은 하나, 모두 실수로 처리</b>
  <br>Javascript의 숫자 관련 데이터 타입은 하나이며, 모두 실수로 처리
- <b>템플릿 리터럴</b>

  - 백틱(``)을 사용하며, 문자열을 표현할 때, 이스케이프 시퀀스 없이도 모두 있는 그대로 적용
  - 템플릿 리터럴 내에 표현식 삽입을 위해서는 해당 표현식을 ${}로 감쌈

- <b>심벌 타입</b>
  <br>다른 값과 중복되지 않는 유일무이한 값, 같은 value를 가진 값으로 생성하여도 그 둘은 동일한 값을 갖지 않음

- <b>데이터 타입의 필요성</b>

  - 값을 저장할 때 확보해야 하는 메모리 공간의 크기 결정
  - 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기 결정
  - 메모리에서 읽어 들인 2진수를 어떻게 해석할지 결정

- <b>동적 타입 언어인 Javscript의 특징</b>

  - Javscript의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론<sup>type inference</sup>)
  - 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있음

- <b>동적 타입 언어의 유연성의 이면</b>
  - 변경이 가능한 변수의 값과 데이터 타입에 의해 유연성이 높지만, 추적이 어렵고 타입 확신을 못해 신뢰성이 떨어진다.
  - 주의사항:
    - 변수는 꼭 필요한 경우에 한해 제한적으로 사용
    - 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제
    - 전역 변수는 사용을 지양
    - 변수(let, var)보다는 상수(const)를 사용해 값의 변경을 억제
    - 변수, 함수, 클래스 등의 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍
