- 지역변수 생명 주기 ⇒ 함수의 생명 주기
  - 그러나 누군가 메모리공간을 참조중이면 해제되지 않고 생존!
- 전역변수 생명 주기 ⇒ 애플리케이션 생명주기

### 전역변수 문제점

- 암묵적 결합
  - 어디서든 참조, 할당 가능 ⇒ 가독성과 위험성 증가
- 긴 생명 주기
  - 메모리 리소스 또한 오래 점유.
- 스코프 체인 상에서 종점에 존재
  - 즉, 변수 검색시 전역변수가 가장 마지막에 검색됨
  - ⇒ 검색 속도가 느리다!
- 네임스페이스 오염
  - 파일이 분리되어 있어도 하나의 전역 스코프 공유
  - 이에, 다른 파일내에 동일한 이름의 변수,함수는 예상치 못한 결과를 가져옴!

### 전역변수의 사용을 억제하려면?

- 왠만하면 지역변수! 스코프는 좁을수록 좋다!

- 즉시 실행 함수

  - 즉시 실행 함수는 단 한번만 호출된다!

  ```jsx
  (function () {
    var foo = 10; // 즉시 실행 함수의 지역 변수
    // ...
  })();

  console.log(foo); // ReferenceError: foo is not defined
  ```

- 네임 스페이스 객체
  - 네임스페이스 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법
  ```jsx
  let MYAPP = {};
  MYAPP.name = "Lee";
  console.log(MYAPP.name); // Lee
  ```
  - 유용한 방법은 아님. 네임 스페이스 객체 자체가 전역변수에 할당되므로.
- 모듈 패턴

  - **클래스를 모방**해서 변수, 함수를 모아 **즉시 실행 함수**로 감싸만든 **하나의 모듈!**
  - 전역변수의 억제 뿐만 아니라, **캡슐화**까지(그러나 한정적인 정보은닉)

  ```jsx
  var Counter = (function () {
    var num = 0;

    return {
      increase() {
        return ++num;
      },
      decrease() {
        return --num;
      },
      getNum() {
        return num;
      },
    };
  })();
  ```

- ES6 모듈
  - 파일 자체에 독자적인 모듈 스코프 제공!
  - script태그에 type=”module” 속성 추가
  ```jsx
  <script type="module" src="lib.mjs"></script>
  <script type="module" src="app.mjs"></script>
  ```
