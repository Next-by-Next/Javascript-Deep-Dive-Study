## 19.1 객체지향 프로그래밍
- 여러 개의 독립적인 단위, 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임

- 추상화, 속성에 대해 이해해보자
  - 속성 : 특징이나 성질을 나타냄
  - 추상화 : 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현하는 것
  - 객체 : 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복잡한 자료구조, 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복잡한 자료구조

```js
// 이름과 주소 속성을 갖는 객체
// person의 다양한 속성 중에 '이름'과 '주소'라는 속성에만 관심이 있어 필요한 속성만 추출하여 표현한 것을 추상화
const person = {
  // 상태 데이터 => 프로퍼티(property)
  name: 'minsun',
  address: 'Seoul', 

  // 동작 => 메서드(method)
  sayHello() {
    return 'Hello, ' + this.name
  }
};

console.log(person.sayHello()) // Hello, minsun
};

console.log(person); // {name: 'minsun', address: 'Seoul'}
```
## 19.2 상속과 프로토타입
### 상속?
- 어떤 객체의 프로퍼티나 메서드를 다른 객체가 상속받아 그대로 사용

- 왜 상속하나요?
  - 불필요한 코드 중복을 제거하고 기존의 코드를 재사용하기 위함.
  - 코드 재사용시 개발 비용을 줄일 수 있음.

```js
// 생성자 함수
function Circle(r) {
  this.r = rl
  this.getArea = function () {
    return Math.PI * this.r ** 2;
  };
}

// 반지름이 1인 인스턴스 생성 
const circle1 = new Circle(1);
// 반지름이 2인 인스턴스 생성 
const circle1 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // flase
```
> console.log(circle1.getArea === circle2.getArea)
- circle1은 r 프로퍼티와 getArea 메서드를 가짐
- circle2은 r 프로퍼티와 getArea 메서드를 가짐
- circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메서드를 중복으로 생성하고 모든 인스턴스가 중복 소유됨.
- 각자의 getArea 메서드를 생성하게 됨. 
  - 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메서드를 중복 소유하는것은 메모리 낭비! 개수가 더 많아 진다면 더 최악!
  - => 상속을 통해 불필요한 중복을 제거하자

```js
function Circle(r) {
  this.r = r;
}

// Circle 유전자에 getArea 메서드를 추가.
// 프로토타입은 Circle 생성자 함수의 prototype 프로터피에 바인딩되어 있음.
Circle.prototype.getArea = function () {
  return Math.PI * r * 2;
};

const circle1 = new Circle(1);
const circle2 = new Circle(2);

console.log(circle1.getArea === circle2.getArea); // True
```
> console.log(circle1.getArea === circle2.getArea); // True

- Circle.prototpye으로 상속 받은 getArea를 circle1과 circle2가 공유하기 때문에 하나의 getArea 메서드를 가리킴.

- 상속의 좋은 점
  - 자신의 상태를 나타내는 r 프로퍼티만 개별적 소유하고 동일한 메서드를 상속을 통해 공유하여 사용하므로 코드의 재사용성에서 매우 유용
  - 공통적으로 사용할 프로퍼티나 메서드를 프로토타입에 미리 구현해두면 별도의 구현 없이 상속을 통해 공유하거나 사용할 수 있음.

## 19.3 프로토타입의 객체
- 모든 객체는 하나의 \[[Prototype]]내부 슬롯을 가짐.
- 내부 슬롯의 값은 프로토타입의 참조임. 하지만 직접 접근 X
- 모든 프로토타입은 생성자 함수와 연결되어 있음.
- 객체가 생성될 때 객체 생성 방식에 따라 프로토타입이 결정되고 \[[Prototype]]에 저장됨.

### 프로토타입의 간접적으로 접근 __proto__
- __proto__ 접근자 프로퍼티 : \[[Prototype]] 내부 슬롯에 간접적을 접근 가능
![객체의프로퍼티](%EA%B0%9D%EC%B2%B4%EC%9D%98%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0.PNG)
