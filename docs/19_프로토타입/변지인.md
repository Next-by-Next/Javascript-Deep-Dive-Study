## 프로토타입

**오늘 읽은 범위** : 19장 1~2

### 0. 프로토타입

---

#### _자바스크립트_

명령형(imperative), 함수형(functional), 프로토타입 기반(prototype-based) 객체지향 프로그래밍(OOP)을 지원하는 멀티 패러다임 프로그래밍 언어다.

클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 객체지향 프로그래밍 능력을 지니고 있는 프로토타입 기반의 객체지향 프로그래밍 언어다.

원시타입(primitive type)을 제외한 `자바스크립트를 이루고 있는 거의 `**모든 것**`이 객체다.`

#### _클래스(class)_

클래스도 함수이며, 기존 프로토타입 기반 패턴의 문법적 설탕(syntactic sugar=문법적기능은 유지하면서 코드를 더 쉽게 읽을 수 있게 해주는 기능)이라고 볼 수 있다.

클래스는 생성자 함수보다 엄격하며, 생성자 함수에서는 제공하지 않는 기능도 제공한다.

클래스는 새로운 객체 생성 메커니즘으로 보는것이 합당하다.

### 1. 객체지향 프로그래밍

---

#### _객체지향 프로그래밍 정의_

객체지향 프로그래밍을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍(imperative programing)의 절차지향적 관점에서 벗어나 여러개의 독립적인 단위, 즉 `객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임`을 말한다.

`속성을 통해 여러개의 값을 하나의 단위로 구성한 복합적인 자료구조`를 **객체**라 하며 **객체지향 프로그래밍**은 `독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임`이다.

객체지향 프로그래밍은 객체의 **상태(state)**를 나타내며, 데이터와 상태 데이터를 조작할 수 있는 **동작(behavior)**을 하나의 논리적 단위로 묶어 생각한다. 따라서 객체는 `상태 데이터(=프로퍼티)와 동작(=메서드)을 하나의 논리적 단위로 묶은 복합적인 자료구조`라고 할 수 있다.

다른 객체와의 관계성을 가질 수 있어, 상속을 받을 수도 있다.

- 추상화(abstraction) : 다양한 속성중에서 프로그램에 필요한 속성만 간추려 표현.

### 2. 상속과 프로토타입

---

#### _상속(ingeritance)_

상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.

상속은 코드의 재사용이란 관점에서 매우 유용하다. 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할  메서드를 프로토타입에 미리 구현해두면, 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 상위 객체인 프로토타입의 자신을 공유하여 사용할 수 없다.

#### _프로토타입(prototype)_

프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. 

**오늘 읽은 범위** : 19장 3

### 3. 프로토타입 객체

---

#### _프로토타입 객체_

프로토타입 객체(또는 줄여서 프로토타입)란 `객체지향 프로그래밍의 근간을 이루는 객체 간 상속을 구현하기 위해 사용`된다. 프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메서드 포함)를 제공한다. 프로토타입을 상속받은 하위(자식) 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.

모든 객체는 하나의 프로토타입을 갖는다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 다음 그림과 같이 서로 연결되어 있다.

<img width="661" alt="image" src="https://github.com/byunjiin/webD/assets/129635857/4807115a-6093-4045-82cc-c0724440ff4b">

자신의  [[Prototype]] 내부 슬롯이 가리키는 프로토타입에 간접적으로 접근할 수 있으며 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타빙ㅂ에 접근할 수 있다.

#### _\_\_proto\_\_ 접근자 프로퍼티_

`모든 객체는 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다.`

- **\_\_proto\_\_는 접근자 프로퍼티** : 프로토타입에 접근하면 내부적으로 \_\_proto\_\_ 프로퍼티의 getter 함수인 [[Get]] 호출. 프로토타입에 접근하면 내부적으로 \_\_proto\_\_ 프로퍼티의 setter 함수인 [[Set]] 호출. 


- **\_\_proto\_\_접근자 프로퍼티는 상속을 통해 사용** : 모든 객체는 상속을 통해 `Object.prototype.__protp__ 접근자 프로퍼티`를 사용 가능

- **\_\_proto\_\_접근자 프로퍼티를 통해 프로토타입에 접근하는 이유** : 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서이다.

- **\_\_proto\_\_접근자 프로퍼티를 코드 내에서 직접 사용하는것은 권장하지 않음** : `Object.prototype.__protp__ 접근자 프로퍼티`를 상속받지 못하여 모든 객체가 사용하지 못할 수도 있다. 대신 참조취득하고 싶을땐 `Object.getPrototypeOf 메서드`를, 교차하고 싶을땐 `Object.setPrototypeOf 메서드`를 사용가능하다.

#### _함수 객체의 prototype 프로퍼티_

`함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.`

모든 객체가 가지고 있는 \_\_proto\_\_접근자 프로퍼티와 함수 객체만이 가지고 있는 prototype프로퍼티는 결국 동일한 프로토타입을 가리킨다. 하지만 프로퍼티를 사용하는 주체가 다르다.

| 구분 | 소유 | 값 | 사용 주체 | 사용 목적  |
| -- | ----| ---| --------| --------|
| `__proto__`접근자 프로퍼티 | 모든 객체 | 프로토타입의 참조 | 모든 객체| 객체가 자신의 프로토타입에 접근 또는 교체하기위해 사용|
| `prototype` 프로퍼티| constructor | 프로토타입의 참조| 생성자 함수 | 생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을  할당하기 위해 사용 |

#### _프로토타입의 constructor 프로퍼티와 생성자 함수_

`모든 프로토타입은 constructor 프로퍼티를 갖는다.` 이는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.