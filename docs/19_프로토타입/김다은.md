# 19장 프로토타입

## 프로토타입

자바스크립트는 **프로토타입 기반의 객체지향 프로그래밍 언어**다. 자바스크립트에서 원시 타입의 값을 제외한 나머지 값은 모두 객체다. 자바스크립트에서는 클래스도 객체인데, 자바와 같은 클래스 기반 프로그래밍 언어에서 다루는 클래스와는 의미가 다르다.

### 1. 객체지향 프로그래밍

객체지향 프로그래밍이란 여러 개의 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다. 객체지향 프로그래밍은 실세계의 실체를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다. 실체에는 다양한 속성이 있다. 그 중 프로그램에 필요한 속성만 간추려 내어 표현하는 것을 **추상화**라고 한다.

객체지향 프로그래밍에서 객체란 **상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조**이다. 각 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유한 기능을 수행하면서 다른 객체와 관계성을 가질 수 있다. 다른 객체와 메시지를 주고받거나 데이터를 처리할 수도 있다. 또는 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다.

<br/>

---

### 2. 상속과 프로토타입

상속은 객체지향 프로그래밍의 핵심 개념으로, 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다. 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 **불필요한 중복을 제거**한다. 다음 예제를 보면서 프로토타입이 중복 코드를 어떻게 제거하는지 보자.

```js
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    return Math.PI * this.radius ** 2;
  };
}
```

위의 Circle 생성자 함수는 인스턴스끼리 radius만 다를 뿐 getArea라는 함수와 그 내용은 모두 같다. 이런 메서드는 단 하나만 생성하여 모든 인스턴스가 공유하여 사용하는 것이 바람직할 것이다.

```js
function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};
```

Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 **부모 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메서드를 상속받는다**. 위와 같은 상황에서 getArea는 프로토타입에 구현되었으므로 생성자 함수가 생성할 모든 인스턴스는 별도의 구현 없이 상위 객체인 프로타티입의 자산을 공유하여 사용할 수 있다.

<br/>

---

## 3. 프로토타입 객체

[[Prototype]]에 저장되는 프로토타입은 객체 생성 방식에 의해 결정된다. 예를 들어 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.

![](https://velog.velcdn.com/images%2Fhang_kem_0531%2Fpost%2Fb28780b6-2c5b-4e1e-9e18-438b90db04d4%2Fimage.png)

객체와 프로토타입과 생성자 함수는 다음 그림과 같이 서로 연결되어 있다. 다음 내용을 보면서 이해해 보자.

<br/>

### 1. \_\_proto\_\_ 접근자 프로퍼티

모든 객체는 \_\_proto\_\_ 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 [[Prototype]] 내부 슬롯에 간접적으로 접근할 수 있다. 그 말인 즉슨 \_\_proto\_\_ 접근자 프로퍼티를 통해 접근할 수 있는 건 객체의 [[Prototype]]이 가리키는 객체인 Object.prototype인 것이다.

#### \_\_proto\_\_는 접근자 프로퍼티다.

16.1절에서 살펴보았듯이 **내부 슬롯은 프로퍼티가 아니다**. 따라서 내부 슬롯에 직접적으로 접근하거나 호출할 수는 없다. [[Prototype]] 내부 슬롯도 마찬가지로 직접 접근할 수 없으며 접근자 프로퍼티를 통해 간접적으로 프로토타입에 접근할 수 있다. **즉 \_\_proto\_\_는 [[Get]], [[Set]] 프로퍼티 어트리뷰트로 구성된 프로퍼티이며, [[Prototype]] 내부 슬롯의 값을 취득하거나 할당할 때 \_\_proto\_\_의 getter 함수와 setter함수가 호출된다**.

#### \_\_proto\_\_ 접근자 프로퍼티는 상속을 통해 사용된다.

\_\_proto\_\_ 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다. 따라서 모든 객체는 \_\_proto\_\_ 접근자 프로퍼티를 직접 소유하는 것이 아닌, 상속해야만 사용할 수 있다.

#### \_\_proto\_\_ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유

접근자 프로퍼티를 통해야만 [[Prototype]] 내부 슬롯에 값에 접근할 수 있는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해서다.

```js
const parent = {};
const child = {};

// 상호 참조
child.__proto__ = parent;
parent.__proto__ = child; // 에러 발생
```

위와 같이 순환 참조 프로토타입 체인이 만들어지면 종점이 존재하지 않기 때문에 프로퍼티를 검색할 때 무한루프에 빠진다. 따라서 \_\_proto\_\_ 프로퍼티를 통해 순환 참조 여부를 체크 후 교체하도록 구현되어 있다.

#### \_\_proto\_\_ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.

모든 객체가 \_\_proto\_\_ 접근자 프로퍼티를 사용할 수 있지는 않다. 객체를 생성할 때 직접 상속을 통해 Object.prototype을 상속받지 않는 객체를 생성할 수도 있기 때문이다.

```js
// Objcet.create()는 지정된 프로토타입 객체 및 속성(property)을 갖는 새 객체를 만든다.
// 즉, 객체를 상속하는 방법 중 하나다.
// 아래의 경우 지정 객체가 null이기 때문에 Object.__proto__를 상속받을 수 없다.
const obj = Object.create(null);

console.log(obj.__proto__); // undefined
```

\_\_proto\_\_ 대신 프로토타입의 참조를 취득 및 교체하고 싶다면 아래와 같은 메서드를 사용한다.

```js
const obj = {};
const parent = { x: 1 };

Object.getPrototypeOf(obj);
Object.setPrototypeOf(obj, parent);

console.log(obj.x); // 1
```

이 두 메서드는 `get Object.prototype.__proto__`와 `set Object.prototype.__proto__`와 처리 내용이 정확히 일치한다.

<br/>

### 2. 함수 객체의 prototype 프로퍼티

**모든 객체 가운데 함수 객체만이 prototype 프로퍼티를 소유한다**. 그리고 이 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 따라서 생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor인 화살표 함수와 축약 표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않으며 프로토타입도 생성하지 않는다. 일반 함수도 prototype 프로퍼티를 소유하지만 객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 아무런 의미가 없다.

**모든 객체가 가지고 있는 \_\_proto\_\_ 접근자 프로퍼티와 함수 객체만 가지고 있는 prototype 프로퍼티는 결국 동일한 프로토타입을 가리킨다.** 하지만 이를 사용하는 주체가 다르다.

| 구분                          | 소유        | 값                | 사용 주체   | 사용 목적                                                                    |
| ----------------------------- | ----------- | ----------------- | ----------- | ---------------------------------------------------------------------------- |
| \_\_proto\_\_ 접근자 프로퍼티 | 모든 객체   | 프로토타입의 참조 | 모든 객체   | 객체가 자신의 프로토타입에 접근 또는 교체하기 위해 사용                      |
| prototype 프로퍼티            | constructor | 프로토타입의 참조 | 생성자 함수 | 생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당하기 위해 사용 |

```js
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');

console.log(Person.prototype === me.__proto__); // true
```

<br/>

### 3. 프로토타입의 constructor 프로퍼티와 생성자 함수

모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 프로퍼티는 자신을 참조하고 있는 생성자 함수를 가리킨다.

![출처: Way in Wayne](https://blog.kakaocdn.net/dn/ewzjT7/btrvXUvk7kd/2PQsltx5veV9e7dESwaqi1/img.png)
