## 19장 프로토타입

> 자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다.

- 클래스
  - ES6에서 클래스 도입
  - 클래스도 함수다.
- 자바스크립트는 객체 기반의 프로그래밍 언어이매 자바스크립트를 이루고 있는 거의 모든것(원시 타입 값을 제외한)이 객체다.

### 19.1 객체지향 프로그래밍

- 프로그램을 명령어 또는 함수의 목록으로 보는 정통적인 명령형 프로그래밍의 절차지향적 관점에서벗어나 여러 개의 독립적 단위, 즉 객체 집합으로 프로그램을 표현하려는 프로그래밍 패러다임
- 다양한 속성 중 프로그램에 필요한 속성만 간추려 내어 표현하는 것 = 추상화
  - ex. 사람에게는 다양한 속성이 있으나 프로그램에는 사람의 이름과 주소라는 속성에만 관심이 있어 이 속성만 간추려 표현하는 것
- 객체 : 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
- 객체지향 프로그래밍 - 상태를 나타내는 데이터와 상태 데이터(프로퍼티)를 조작할 수 있는 동작(메서드)을 하나의 논리적인 단위로 묶어 생각한다.

### 19.2 상속과 프로토타입

- 상속 : 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것
- 생성자 함수는 모든 인스턴스가 동일한 내용의 메서드를 사용하여 하나만 생성하여 모든 인스턴스가 공유해서 사용해도 되는 경우에도 인스턴스를 생성할 때마다 중복 생성하고, 모든 인스턴스가 중복 소유한다.
- 상속을 통해 불필요한 중복을 제거할 수 있는데 자바스크립트는 프로토타입을 기반으로 상속을 구현한다.
- ex.

  ```tsx
  function Circle(radius) {
    this.radius = radius;
  }

  // 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.
  Circle.prototype.getArea = function () {
    return Math.PI * this.radius ** 2;
  };
  ```

### 19.3 프로토타입 객체

- 프로토타입 객체(프로토타입)
  - 객체 간 상속을 구현하기 위해 사용
  - 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공
  - 모든 객체는 하나의 프로토타입을 가지고 모든 프로토타입은 생성자 함수와 연결되어 있음
    ![Untitled](https://github.com/Next-by-Next/Javascript-Deep-Dive-Study/assets/78250089/77f51a20-ce91-426b-b604-3733cc306e81)
    - 내부 슬롯에는 직접 접근할 수 없지만, `__proto__` 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근 가능
    - 프로토타입은 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있음
- \[\[Prototype\]\]
  - 모든 객체는 \[\[Prototype\]\]이라는 내부 슬롯을 가지며, 이 내부 슬롯의 값은 프로토타입의 참조임
  - 객체가 생성될 때 객체 생성 방식에 따라 프로토타입이 결정되고 \[\[Prototype\]\]에 저장됨

**19.3.1 \_\_proto\_\_ 접근자 프로퍼티**

- 모든 객체는 \_\_proto\_\_ 접근자 프로퍼티를 통해 자신의 프로토타입(\[\[Prototype\]\] 내부 슬롯)에 간접적으로 접근할 수 있음
- \_\_proto\_\_는 접근자 프로퍼티다.
  - 내부 슬롯을 프로퍼티가 아니라서 원칙적으로 집적적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다. 단, 일부 내부 슬롯과 내부 메서드에 한해 간접적으로 접근할 수 있는 수단을 제공하기는 하며 \_\_proto\_\_ 접근자 프로퍼티를 통해 간접적으로 \[\[Prototype\]\] 내부 슬롯에 접근할 수 있다.
- \_\_proto\_\_ 접근자 프로퍼티는 상속을 통해 사용된다.
  - 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티다.
- \_\_proto\_\_ 접근자 프로퍼티를 통해 프로토타입에 접근하는 이유
  - 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위해
- \_\_proto\_\_ 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 권장하지 않는다.
  - 모든 객체가 \_\_proto\_\_ 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문에 코드 내에서 직접 사용하는 것은 권장하지 않는다.

**19.3.2 함수 객체의 prototype 프로퍼티**

- 함수 객체만이 소유하는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.

**19.3.3 프로토타입의 constructor 프로퍼티와 생성자 함수**

- constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리키며 생성자 함수(함수 객체)가 생성될 때 연결이 이뤄진다.

### 19.4 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입

- constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 생성자 함수다.
- new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 리터럴 표기법에 의한 객체 생성방식도 있음
  - 프로토타입이 존재하지만 constructor 프로퍼티가 가리키는 생성자 함수가 반드시 객체를 생성한 생성자 함수라고 단정 지을 수 없음
- 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재함

### 19.5 프로토타입의 생성 시점

- 프로토타입은 생성자 함수가 생성되는 시점에 생성된다.

**19.5.1 사용자 정의 생성자 함수와 프로토타입 생성 시점**

- 생성자 함수로서 호출할 수 있는 함수, constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.
- 빌트인 생성자 함수가 아닌 사용자 정의 생성자 함수는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토 타입도 더불어 생성되며, 생성한 프로토타입의 프로토타입은 언제나 `Object.prototype`이다.

**19.5.2 빌트인 생성자 함수와 프로토타입 생성 시점**

- 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점(전역 객체가 생성되는 시점)에 프로토타입 생성

### 19.6 객체 생성 방식과 프로토타입의 결정

- 객체 생성 방식
  - 객체 리터럴
  - Object 생성자 함수
  - 생성자 함수
  - Object.create 메서드
  - 클래스
- 모든 객체는 추상 연산 OrdinaryObjectCreate에 의해 생성됨
  - 프로토타입은 OrdinaryObjectCreate에 전달되는 인수에 의해 결정됨
    - 인수는 객체 생성 방식에 의해 결정됨

**19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입**

- 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.

**19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입**

- Object 생성자 함수에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.

**19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입**

- 생성자 함수에 의해 생성되는 객체의 프로토타입은 셍상지 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.

### 19.7 프로토타입 체인

- 프로토타입 체인 : 자바스크립트에서 객체의 프로퍼티에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 \[\[Prototype\]\] 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하는 것 (자바스크립트가 객체지향 프로그래밍의 상속을 구현하는 메커니즘)
- 프로토타입 체인의 종점 : 프로토타입의 프로토타입(프로토타입 체인의 최상위에 위치하는 객체)은 언제나 Object.prototype
- 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘 / 스코프 체인은 식별자 검색을 위한 메커니즘
- 스코프 체인과 프로토타입 체인은 서로 연관없이 별도로 동작하는 것이 아니라 서로 협력하여 식별자와 프로퍼티를 검색하는 데 사용됨

### 19.8 오버라이딩과 프로퍼티 섀도잉

- 프로토타입 프로퍼티 : 프로토타입이 소유한 프로퍼티
- 인스턴스 프로퍼티 : 인스턴스가 소유한 프로퍼티
- 프로퍼티 섀도잉 : 상속 관계에 의해 프로퍼티가 가려지는 현상
  - 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가/삭제하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는/삭제하는 것이 아니라 인스턴스 프로퍼티로 추가/삭제한다.
  - 이때 인스턴스 메서드는 프로토타입 메서드를 오버라이딩하고 프로토타입 메서드는 가려진다.

### 19.9 프로토타입의 교체

- 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다.

**19.9.1 생성자 함수에 의한 프로토타입의 교체**

- 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.
- 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살릴 수 있다.

**19.9.2 인스턴스에 의한 프로토타입의 교체**

- 인스턴스의 \_\_proto\_\_ 접근자 프로퍼티를 통해 프로토타입을 교체할 수 있다.
- \_\_proto\_\_ 접근자 프로퍼티를 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것이다.
- 프로토타입으로 교체한 객체에는 constructor 프로퍼티와 생성자 함수 간의 연결이 파괴된다.
- 생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체 차이
  ![생성자 함수에 의한 프로토타입 교체](https://github.com/Next-by-Next/Javascript-Deep-Dive-Study/assets/78250089/23378203-01ab-4227-81ea-3ab4526ce37f)
  ![인스턴스에 의한 프로토타입 교체](https://github.com/Next-by-Next/Javascript-Deep-Dive-Study/assets/78250089/4a0daac4-4737-448f-a7be-7849936447dc)

### 19.10 instanceof 연산자

- 객체 instanceof 생성자 함수
- 우변의 생성자 함수의 prototype에 바인딩된 객체가 좌변의 객체의 프로토타입 체인 상에 존재하면 true로 평가되고, 그렇지 않은 경우에는 false로 평가된다.

### 19.11 직접 상속

**19.11.1 Object.create에 의한 직접 상속**

- Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.
  - 첫 번째 매개변수 - 생성할 객체의 프로토타입으로 지정할 객체 전달
  - (두 번째 매개변수) - 생성할 객체의 프로퍼티 키와 프로퍼티 디스크립터 객체로 이루어진 객체
- Object.create 메서드 장점
  - new 연산자가 없이도 객체를 생성할 수 있다.
  - 프로토타입을 지정하면서 객체를 생성할 수 있다.
  - 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.
- 프로토타입 체인의 종점에 위치하는 객체(Object.prototype 빌트인 메서드 사용 불가)를 생성할 수 있기 때문에 ESLint에서는 Object.prototype의 빌트인 메서드를 객체가 직접 호출하는 것을 권장하지 않는다.
  -> Function.prototype.call 메서드로 간접적으로 호출하는 것이 좋다.

**19.11.2 객체 리터럴 내부에서 \_\_proto\_\_에 의한 직접 상속**

- Object.create 메서드 두 번째 인자로 프로퍼티를 정의하는 것은 번거롭다.
  -> ES6에서는 객체 리터럴 내부에서 \_\_proto\_\_ 접근자 프로퍼티를 사용해 직접 상속을 구현할 수 있다.
