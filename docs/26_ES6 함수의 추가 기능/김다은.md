# 26장 ES6 함수의 추가 기능

## 1. 함수의 구분

**ES6 이전의 모든 함수는 일반 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있었다**. 이는 혼란스러우며 실수를 유발할 가능성이 있고 성능에도 좋지 않았다. 이러한 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 구분했다.

| ES6 함수의 구분    | constructor | prototype | super | arguments |
| ------------------ | ----------- | --------- | ----- | --------- |
| 일반 함수(Normal)  | ⭕️         | ⭕️       | ❌    | ⭕️       |
| 메서드(Method)     | ❌          | ❌        | ⭕️   | ⭕️       |
| 화살표 함수(Arrow) | ❌          | ❌        | ❌    | ❌        |

<br/>

## 2. 메서드

> 축약 표현으로 정의된 함수만을 의미한다.

```js
const obj = {
  x: 1,
  // foo는 메서드다.
  foo() {
    return this.x;
  },

  // bar에 바인딩된 함수는 메서드가 아닌 일반 함수다.
  bar: function () {
    return this.x;
  },
};
```

- 메서드는 인스턴스를 생성할 수 없는 non-constructor이므로 생성자 함수로서 호출할 수 없다.
- 메서드는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없다.
- 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다. 따라서 super 참조가 가능하다.
- 메서드는 arguments를 갖는다.

<br/>

## 3. 화살표 함수

> 화살표(=>)를 사용하여 기존의 함수 정의 방식보다 간략하게 함수를 정의한 방법. 내부 동작도 기존 함수보다 간략하다.

- 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
- 화살표 함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없다.
- 화살표 함수는 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.

❗️ **화살표 함수는 스코프 체인 상에서 가장 가까운 화살표 함수가 아닌 함수의 this, arguments, super, new.target을 참조한다**.
