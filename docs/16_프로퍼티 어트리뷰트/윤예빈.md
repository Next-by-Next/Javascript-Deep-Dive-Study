> **오늘 읽은 범위** : 16장 프로퍼티 어트리뷰트 (219p ~ 233p) \
> **날짜** : 2023.11.21 ~ 11.22

## 📂 `목차`

[1. 내부 슬롯과 내부 메서드](#-내부-슬롯과-내부-메서드)  
[2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체](#-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체)  
[3. 데이터 프로퍼티와 접근자 프로퍼티](#-데이터-프로퍼티와-접근자-프로퍼티)  
[4. 프로퍼티 정의](#-프로퍼티-정의)  
[5. 객체 변경 방지](#-객체-변경-방지)  

<br>

## 🔎 내부 슬롯과 내부 메서드

#### 프로퍼티 어트리뷰를 이해하기 위해 먼저 내부 슬롯과 내부 메서드의 개념에 대해 알아보자

- 내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다.
- ECMAScript 사양에 등장하는 이중 대괄호`([[...]])`로 감싼 이름들이 내부 슬롯과 내부 메서드다.

#### 내부 슬롯과 내부 메서드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작 하지만 직접 접근할 수 있도록공개된 객체의 프로퍼티는 아니다.

- 즉, 내부 슬롯과 내부 메서드는 자바스크립트 엔진의 내부 로직이므로 원칙적으로 자바스크립트는 내부 슬롯과 내부 메서드에 직접적으로 접근하거나 호출할 수 있는 방법을 제공하지 않는다.
- 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.
  - ```js
    const o = {};
    // 내부 슬롯은 자바스크립트 엔진의 내부 로직아므로 직접 접근할 수 없다.
    o.[[Prototype]] // -> Uncaught SyntaxError: Unexpected token '['
    // 단, 일부 내부 슬롯과 내부 메서드에 한하여 간접적으로 접근할 수 있는 수단을 제공하기는 한다.
    o.__proto__// -> Object.prototype
    ```

<br>

## 🔎 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체

#### 자바스크립트 엔진은 프로퍼티를 생성할 때 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰를 기본값으로 자동 정의한다.

- 프로퍼티의 상태란 프로퍼티의 값, 값의 갱신 가능 여부, 열거 가능 여부, 재정의 가능 여부를 말한다.
- 프로퍼티 어트리뷰는 자바스크립트 엔진이 관리하는 내부 상태 값인 내부 슬롯 `[[Value]]`, `[[Writable]]`, `[[Enumerable]]`, `[[Configurable]]`이다.
  - 따라서 프로퍼티 어트리뷰에 직접 접근할 수 없지만 Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로확인할 수는 있다.
  - ```js
    const person = {
        name: 'Lee'
    };
    // 프로퍼티 어트리뷰 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.
    console.log(Object.getOwnPropertyDescriptor(person.'name'));
    //{value:"Lee", writable: true, enumerable: true, configurable: true}
    ```

<br>

## 🔎 데이터 프로퍼티와 접근자 프로퍼티

> #### 프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다.
>
> - `데이터 프로퍼티`
>   - 키와 값으로 구성된 일반적인 프로퍼티다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티다.
> - `접근자 프로퍼티`
>   - 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티다.

<br>

### ✏️ 데이터 프로퍼티

#### 이 프로퍼티 어트리뷰는 자바스크립트 엔진이 프로퍼티를 생성할때 기본값으로 자동 정의된다.

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                                                                                                                                                  |
| ------------------- | ----------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `[[Value]]`         | value                               | 프로퍼티 키를 통해 프로퍼티 값에 접근하면 반환되는 값이다.                                                                                                                                            |
|                     |                                     | 프로퍼티 키를 통해 프로퍼티 값을 변경하면 [[Value]]에 값을 재할당한다. 이때 프로퍼티가 없으면 프로퍼티를 동적 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.                                   |
| `[[Writable]]`      | writable                            | 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.                                                                                                                                           |
|                     |                                     | [[Writable]]의 값이 false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.                                                                                           |
| `[[Enumerable]]`    | enumerable                          | 프로퍼티의 열거 기능 여부를 나타내며 불리언 값을 갖는다.                                                                                                                                              |
|                     |                                     | [[Enumerable]]의 값이 false인 경우 해당 프로퍼티는 for...in문이나 Object.keys 메서드 등으로 열거할 수 없다.                                                                                           |
| `[[Configurable]]`  | configurable                        | 프로퍼티의 재정의 기능 여부를 나타내며 불리언 값을 갖는다.                                                                                                                                            |
|                     |                                     | [[Configurable]]의 값이 false인 경우 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]아 true인 경우 [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. |

<br>

---

<br>

### ✏️ 접근자 프로퍼티

#### 접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수로 구성된 프로퍼티다.

| 프로퍼티 어트리뷰트 | 프로퍼티 디스크립터 객체의 프로퍼티 | 설명                                                                                                                                                                                                                           |
| ------------------- | ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `[[Get]]`           | get                                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수다. 즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수가 호출되고 그 결과 프로퍼티 값을 반환된다.      |
| `[[Set]]`           | set                                 | 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수다. 즉 접근자 프로퍼티 키로 프로퍼티 값을 지정하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다. |
| `[[Enumerable]]`    | enumerable                          | 데이터 프로퍼티의 [[Enumerable]]과 같다.                                                                                                                                                                                       |
| `[[Configurable]]`  | configurable                        | 데이터 프로퍼티의 [[Configurable]]과 같다.                                                                                                                                                                                     |

#### 접근자 함수는 getter/setter 함수라고도 부른다.

- 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다.
- ```js
  const person = {
    // 데이터 프로퍼티
    firstName: "Ungmo",
    lastName: "Lee",

    // fullName은 접근자 함수로 구성된 접근자 프로퍼티다.

    // getter 함수
    get fullName() {
      return `${this.firstName} ${this.LastName}`;
    },

    // setter 함수
    set fullName(name) {
      // 배열 디스트럭처링 할당
      [this.firstName, this.lastName] = name.split("");
    },
  };

  // 데이터 프로퍼티를 통한 프로퍼티 값의 참조
  console.log(person.firstName + "" + person.lastName); // Ungmo Lee

  // 접근자 프로퍼티를 통한 프로퍼티 값의 저장
  // 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.
  person.fullName = "Heegun Lee";
  console.log(person); // {firstName: "Heegun", lastName: "Lee"}

  // 접근자 프로퍼티를 통한 프로퍼티 값의 참조
  // 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.
  console.log(person.fullName); // Heegun Lee

  // firstName은 데이터 프로퍼티다.
  let descriptor = Object.getOwnPropertyDescriptor(person, "firstName");
  console.log(descriptor);
  // {value:"Heegun", writable: true, enumerable: true, configurable: true}

  // fullName은 접근자 프로퍼티다.
  descriptor = Object.getOwnPropertyDescriptor(person, "fullName");
  console.log(descriptor);
  // {get: f, set: f, enumerable: true, configurable: true}
  ```

#### 접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메서드가 호출되어 다음과 같이 동작한다.

- 1️⃣ 프로퍼티 키가 유효한지 환인한다. 프로퍼티 키는 문자열 또는 심벌이어야 한다. 프로퍼티 키 "fullName"은 문자열이므로 유효한 프로퍼티 키다.
- 2️⃣ 프로토타입 체인에서 프로퍼티를 검색한다. person 객체에 fullName 프로퍼티가 존재한다.
- 3️⃣ 검색된 fullName 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName 프로퍼티는 접근자 프로퍼티다.
- 4️⃣ 접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메서드가 반환하는 프로퍼티 디스크립터 객체의 get 프로퍼티 값과 같다.

> #### ✔️ 프로토타입
>
> - 프로토타입은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체다.
> - 프로토타입은 하위(자식) 객체에서 자신의 프로퍼티와 메서드를 상속한다.
> - 프로토타입 객체의 프로퍼티나 메서드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메서드인 것처럼 자유롭게 사용할 수 있다.

<br>

## ✏️ 프로퍼티 정의

#### 프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.

#### Object.defineProperty 메서드를 사용하면 프로퍼티의 어트리뷰를 정의할 수 있다.

- 인수로는 객체의 참조와 데이터 프로퍼티의 키인 문자열, 프로퍼티 디스크립터 객체를 전달한다.
- ```js
  const person = {};
  // 데이터 프로퍼티 정의
  Object.defineProperty(person, 'firstName', {
    value: 'Ungmo',
    writable: true,
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(person, 'lastName',{
    value:'Lee'
  });
  let descriptor = Object.getOwnPropertyDescriptor(person.'firstName');
  console.log('firstName, descriptor');
  // firstName {value: "Ungmo", writable: true, enumerable: true, configurable: true}

  // 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.
  descriptor = Object.getOwnPropertyDescriptor(person.'lastName');
  console.log('lastName, descriptor');
  // lastName {value: "Lee", writable: false, enumerable: false, configurable: false}

  // [[Enumerable]]의 값이 false인 경우
  // 해당 프로퍼티는 for...in 문이나 Object.keys 등으로 열거할 수 없다.
  // lastName 프로퍼티는 [[Enumerable]]의 값이 false이므로  열거 되지 않는다.
  console.log(Object.keys(person)); // ["firstName"]

  // [[Writable]]의 깂이 false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.
  // lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.
  // 이때 프로퍼티를 삭제하려면 에러는 발생하지 않고 무시된다.
  person.lastName = 'Kim';

  // [[Configurable]]의 값이 false인 경우 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.
  // lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.
  // 이때 프로퍼티를 삭제하려면 에러는 발생하지 않고 무시된다.
  delete person.lastName;

  // [[Configurable]]의 값이 false인 경우 해당 프로퍼티를 삭제할 수 없다.
  // Object.defineProperty(person, 'lastName', {enumerable : true});
  // Uncaught TypeError: cannot redefine property: lastName

  descriptor = Object.getOwnPropertyDescriptor(person, 'lastName');
  console.log('lastName', descriptor);
  // lastName {value: "Lee", writable: false, enumerable: false, configurable: false}

  // 접근자 프로퍼티 정의
  Object.defineProperty(person, 'fullName'{
    // getter 함수
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    // setter 함수
    set(name) {
      [this.firstName, this.lastName] = name.split(' ');
    },
    enumerable : true,
    configurable : true
  });
  descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');
  console.log('fullName', descriptor);
  // fullName {get: f, set: f, enumerable: true, configurable: true}

  person.fullName = 'Heegun Lee';
  console.log(person); // {firstName : "Heegun", LastName : "Lee"}
  ```

#### ✔️ `Object.defineProperty` 메서드로 프로퍼티를 정의할 때 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있다.

| 프로퍼티 디스크립터 객체의 프로퍼티 | 대응하는 프로퍼티 어트리뷰트 | 생략했을 때의 기본값 |
| ----------------------------------- | ---------------------------- | -------------------- |
| value                               | [[Value]]                    | undefined            |
| get                                 | [[Get]]                      | undefined            |
| set                                 | [[Set]]                      | undefined            |
| writable                            | [[Writable]]                 | false                |
| enumerable                          | [[Enumerable]]               | false                |
| configurable                        | [[Configurable]]             | false                |

<br>

#### `Object.defineProperty` 메서드는 한번에 하나의 프로퍼티만 정의할 수 있다.

#### `Object.defineProperties` 메서드를 사용하면 여러 개의 프로퍼티를 한 번에 정의할 수 있다.

```js
const person = {};

Object.defineProperties(person, {
  // 데이터 프로퍼티 정의
  firstName: {
    value: "Ungmo",
    writable: true,
    enumerable: true,
    configurable: true,
  },
  lastName: {
    value: "Lee",
    writable: true,
    enumerable: true,
    configurable: true,
  },
  // 접근자 프로퍼티
  fullName: {
    // getter 함수
    get() {
      return `${this.firstName} ${this.lastName}`;
    },
    set(name) {
      [this.firstName, this.lastName] = name.split(" ");
    },
    enumerable: true,
    configurable: true,
  },
});
person.fullName = "Heegun Lee";
console.log(person); // {firstName : "Heegun", LastName : "Lee"}
```

## ✏️ 객체 변경 방지

#### 객체는변경 가능한 값이므로 재할당 없이 변경할 수 있다.

- 즉 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티 값을 갱신할 수 있으며, `Object.defineProperty` 또는 `Object.defineProperties` 메서드를 사용하여 프로퍼티 어트리뷰를 재정의할 수 도 있다.

### 1️⃣ 객체 확장 금지

- `Object.PrevenExtensions` 메서드는 객체의 확장을 금지한다.
  - 확장이 금지된 객체는 프로퍼티 추가가 금지된다.

### 2️⃣ 객체 밀봉

- `Object.seal` 메서드는 객체를 밀봉한다.
  - 밀봉된 객체는 읽기와 쓰기만 가능하다.

### 3️⃣ 객체 동결

- `Object.freeze` 메서드는 객체를 동결한다.
  - 동결된 객체는 읽기만 가능하다.

### 4️⃣ 불변 객체

- 변경 방지 메서드들은 얕은 변경 방지로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못한다.
  - `Object.freeze` 메서드로 객체를 동결하여도 중첩 객체까지 동결할 수 없다.
