## 💡 23.1 소스코드의 타입

- 소스코드 타입에 따라 -> 소스 코드 **평가** -> **실행** 컨택스트 생성

- **전역 코드**
  - 전역 스코프 생성 (전역 변수 관리를 위해)
  - 전역 변수/함수를 전역 객체의 프로퍼티/메서드로 바인딩 (참조하기 위해 전역 객체와 연결하는 것임)
- **함수 코드**
  - 지역 스코프 생성 (지역 변수, 매개변수, arguments 객체 관리를 위해)
  - 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 함
- **eval 코드**
  - strict mode에서 자신만의 독자적인 스코프 생성
- **모듈 코드**
  - 모듈별로 독립적은 스코프 생성

## 💡 23.2 소스코드의 평가와 실행

- **소스코드 평가** + **소스코드 실행** 2단계
  ![](https://velog.velcdn.com/images/pipi/post/31e99f3a-69a4-4fe1-b1a6-ed30382157a3/image.png)

```js

```

- **소스코드 평가**

  - 실행 컨텍스트 생성
  - 변수/함수 선언문 실행 -> 생성된 변수/함수 식별자를 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록

- **소스코드 실행**

  - 선언문을 제외한 소스코드가 순차적으로 실행(런타임 시작)
  - 소스코드 실행에 필요한 정보들은 <u>실행 컨텍스트가 관리하는 스코프</u>서 얻는다. + 소스코드의 실행결과는 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록된다.

- **동작 예시**
  ```js
  var x;
  x = 1;
  ```
  - **소스코드 평가**
    - 변수 선언문 (`var x;`) 실행.
    - 식별자 `x`는 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록되고, `undefined`로 초기화된다.
  - **소스코드 실행**
    - 변수 할당문 (`x = 1;`) 실행.
    - 이때, x가 선언된 변수인지 확인하기 위해 <u>실행 컨텍스트가 관리하는 스코프</u>에 x 변수가 등록되어 있는지 확인한다.
    - 선언된 변수(스코프에 등록된 변수)라면 값을 할당하고, 할당 결과를 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록한다!

## 💡 23.3 실행 컨텍스트의 역할

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

- **1. 전역 코드 평가**

  - `const x, const y` 변수/함수 선언문 실행 -> 전역 변수/함수가 <u>실행 컨텍스트가 관리하는 전역 스코프</u>에 등록된다.
  - `var`로 선언한 변수/함수는 전역 객체의 프로퍼티/메서드가 된다.

- **2. 전역 코드 실행**

  - 런타임 시작. 전역 변수에 값이 할당된다. `x = 1, y = 1`
  - 함수가 호출되며, 이때 전역코드의 실행을 중단하고, 함수 내부로 진입한다. `foo(100)`

- **3. 함수 코드 평가**

  - 함수 내부로 진입, `const x, const y` 매개변수/지역 변수 선언문이 실행 -> <u>실행 컨텍스트가 관리하는 지역 스코프</u>에 등록된다.
  - `argumnets` 객체가 생성되어 지역 스코프에 등록되고, `this` 바인딩이 결정된다.

- **4. 함수 코드 실행**

  - 런타임 시작. 지역 변수/매개변수에 값이 할당된다. `x = 10, y = 20`
  - `console.log` 메서드를 호출
  - `console` 식별자를 찾아서... 스코프 체인 검색한다.(이를 위해 함수 지역 스코프는 전역 스코프(상위 스코프)와 연결되어야 한다)
    - 참고로, `console` 식별자는 전역 객체의 프로퍼티이다. 즉 전역 객체의 프로퍼티 또한, 전역 스코프를 통해 검색이 가능하다.
  - `console` 객체의 프로토타입 체인에서,`log` 프로퍼티를 찾아서...
  - 이후, 표현식 `a + x + y` 가 평가되는데, 식별자(`a`,`x`,`y`) 값은 스코프 체인을 통해 검색한다.

- 즉, 코드가 실행되려면

  - 스코프를 구분하여 값이 관리되어야하고,
  - 스코프 체인이 형성되어야 하고,
  - 전역객체의 프로퍼티 또한, 전역 스코프를 통해 검색이 가능해야한다.
  - => 이를 **실행 컨텍스트**가 수행한다!

- **실행 컨텍스트**
  - 식별자를 등록하고 관리하는 스코프(**실행 컨텍스트의 랙시컬 환경**) + 코드 실행 순서 관리(**실행 컨텍스트 스택**)를 구현한 내부 매커니즘
  - **모든 코드는 🧩 실행 컨텍스트를 통해 실행되고, 관리된다!**

## 💡 23.4 실행 컨텍스트 스택

- **🚨 코드의 실행 순서를 관리한다**.
- 실행 컨텍스트는 **스택** 자료구조로 관리된다.
- 실행 컨텍스트의 최상위 스택은 **현재 실행중인 코드의 실행 컨텍스트**이다!

```js
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

![](https://velog.velcdn.com/images/pipi/post/db4f8330-9042-49e1-9a01-f454968dcf82/image.png)

## 💡 23.5 렉시컬 환경

- 🚨 **스코프, 식별자를 관리한다.**
- 식별자, 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조.
- 2개의 컴포넌트(`Environment Record` + `Outer Lexical Environment Reference`)로 구성
  - `Environment Record` 환경 레코드 -> 식별자, 식별자에 바인딩된 값 관리
  - `Outer Lexical Environment Reference` 외부 렉시컬 환경에 대한 참조 -> 상위 코드의 렉시컬 환경(상위 스코프)을 가리킴.
