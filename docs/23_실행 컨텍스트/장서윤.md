## 💡 23.1 소스코드의 타입

- 소스코드 타입에 따라 -> 소스 코드 **평가** -> **실행** 컨택스트 생성

- **전역 코드**
  - 전역 스코프 생성 (전역 변수 관리를 위해)
  - 전역 변수/함수를 전역 객체의 프로퍼티/메서드로 바인딩 (참조하기 위해 전역 객체와 연결하는 것임)
- **함수 코드**
  - 지역 스코프 생성 (지역 변수, 매개변수, arguments 객체 관리를 위해)
  - 지역 스코프를 전역 스코프에서 시작하는 스코프 체인의 일원으로 연결해야 함
- **eval 코드**
  - strict mode에서 자신만의 독자적인 스코프 생성
- **모듈 코드**
  - 모듈별로 독립적은 스코프 생성

## 💡 23.2 소스코드의 평가와 실행

- **소스코드 평가** + **소스코드 실행** 2단계
  ![](https://velog.velcdn.com/images/pipi/post/31e99f3a-69a4-4fe1-b1a6-ed30382157a3/image.png)

```js

```

- **소스코드 평가**

  - 실행 컨텍스트 생성
  - 변수/함수 선언문 실행 -> 생성된 변수/함수 식별자를 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록

- **소스코드 실행**

  - 선언문을 제외한 소스코드가 순차적으로 실행(런타임 시작)
  - 소스코드 실행에 필요한 정보들은 <u>실행 컨텍스트가 관리하는 스코프</u>서 얻는다. + 소스코드의 실행결과는 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록된다.

- **동작 예시**
  ```js
  var x;
  x = 1;
  ```
  - **소스코드 평가**
    - 변수 선언문 (`var x;`) 실행.
    - 식별자 `x`는 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록되고, `undefined`로 초기화된다.
  - **소스코드 실행**
    - 변수 할당문 (`x = 1;`) 실행.
    - 이때, x가 선언된 변수인지 확인하기 위해 <u>실행 컨텍스트가 관리하는 스코프</u>에 x 변수가 등록되어 있는지 확인한다.
    - 선언된 변수(스코프에 등록된 변수)라면 값을 할당하고, 할당 결과를 <u>실행 컨텍스트가 관리하는 스코프</u>에 등록한다!

## 💡 23.3 실행 컨텍스트의 역할

```js
// 전역 변수 선언
const x = 1;
const y = 2;

// 함수 정의
function foo(a) {
  // 지역 변수 선언
  const x = 10;
  const y = 20;

  // 메서드 호출
  console.log(a + x + y); // 130
}

// 함수 호출
foo(100);

// 메서드 호출
console.log(x + y); // 3
```

- **1. 전역 코드 평가**

  - `const x, const y` 변수/함수 선언문 실행 -> 전역 변수/함수가 <u>실행 컨텍스트가 관리하는 전역 스코프</u>에 등록된다.
  - `var`로 선언한 변수/함수는 전역 객체의 프로퍼티/메서드가 된다.

- **2. 전역 코드 실행**

  - 런타임 시작. 전역 변수에 값이 할당된다. `x = 1, y = 1`
  - 함수가 호출되며, 이때 전역코드의 실행을 중단하고, 함수 내부로 진입한다. `foo(100)`

- **3. 함수 코드 평가**

  - 함수 내부로 진입, `const x, const y` 매개변수/지역 변수 선언문이 실행 -> <u>실행 컨텍스트가 관리하는 지역 스코프</u>에 등록된다.
  - `argumnets` 객체가 생성되어 지역 스코프에 등록되고, `this` 바인딩이 결정된다.

- **4. 함수 코드 실행**

  - 런타임 시작. 지역 변수/매개변수에 값이 할당된다. `x = 10, y = 20`
  - `console.log` 메서드를 호출
  - `console` 식별자를 찾아서... 스코프 체인 검색한다.(이를 위해 함수 지역 스코프는 전역 스코프(상위 스코프)와 연결되어야 한다)
    - 참고로, `console` 식별자는 전역 객체의 프로퍼티이다. 즉 전역 객체의 프로퍼티 또한, 전역 스코프를 통해 검색이 가능하다.
  - `console` 객체의 프로토타입 체인에서,`log` 프로퍼티를 찾아서...
  - 이후, 표현식 `a + x + y` 가 평가되는데, 식별자(`a`,`x`,`y`) 값은 스코프 체인을 통해 검색한다.

- 즉, 코드가 실행되려면

  - 스코프를 구분하여 값이 관리되어야하고,
  - 스코프 체인이 형성되어야 하고,
  - 전역객체의 프로퍼티 또한, 전역 스코프를 통해 검색이 가능해야한다.
  - => 이를 **실행 컨텍스트**가 수행한다!

- **실행 컨텍스트**
  - 식별자를 등록하고 관리하는 스코프(**실행 컨텍스트의 랙시컬 환경**) + 코드 실행 순서 관리(**실행 컨텍스트 스택**)를 구현한 내부 매커니즘
  - **모든 코드는 🧩 실행 컨텍스트를 통해 실행되고, 관리된다!**

## 💡 23.4 실행 컨텍스트 스택

- **🚨 코드의 실행 순서를 관리한다**.
- 실행 컨텍스트는 **스택** 자료구조로 관리된다.
- 실행 컨텍스트의 최상위 스택은 **현재 실행중인 코드의 실행 컨텍스트**이다!

```js
const x = 1;

function foo() {
  const y = 2;

  function bar() {
    const z = 3;
    console.log(x + y + z);
  }
  bar();
}

foo(); // 6
```

![](https://velog.velcdn.com/images/pipi/post/db4f8330-9042-49e1-9a01-f454968dcf82/image.png)

## 💡 23.5 렉시컬 환경

- 🚨 **스코프, 식별자를 관리한다.**
- 식별자, 식별자에 바인딩된 값, 상위 스코프에 대한 참조를 기록하는 자료구조.
- 2개의 컴포넌트(`Environment Record` + `Outer Lexical Environment Reference`)로 구성
  - `Environment Record` 환경 레코드 -> 식별자, 식별자에 바인딩된 값 관리
  - `Outer Lexical Environment Reference` 외부 렉시컬 환경에 대한 참조 -> 상위 코드의 렉시컬 환경(상위 스코프)을 가리킴.

## 💡 23.6 실행 컨텍스트의 생성과 식별자 검색 과정

> 🧩 **실행 컨텍스트** : 코드 실행 순서
> 🧩 실행 컨텍스트의 **렉시컬 환경** : 식별자/스코프 관리

### ✨ 23.6.1 전역 객체 생성

- 전역 코드가 평가되기 전, [전역 객체(21장)](https://velog.io/@pipi/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-Deep-Dive-21%EC%9E%A5#-214-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4)가 생성된다.
  - 참고로, 전역 객체의 프로퍼티에는 모든 표준 빌트인 객체(`Object`,`String`)가 존재한다.
  - => 즉, 전역 객체도 프로토타입 체인의 일원이다! + 표준 빌트인 객체도 생성된다!

### ✨ 23.6.2 전역 코드 평가

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20); // 42
```

- 1️⃣ 전역 실행 컨텍스트 생성
  - 2️⃣ 전역 렉시컬 환경 생성
    - 3️⃣ 전역 환경 레코드 생성
      - 4️⃣ 객체 환경 레코드 생성
      - 5️⃣ 선언적 환경 레코드 생성
    - 6️⃣ this 바인딩
    - 7️⃣ 외부 렉시컬 환경에 대한 참조 결정

![](https://velog.velcdn.com/images/pipi/post/ac4ffbd1-91b8-4002-a639-e18dd73a676e/image.png)

---

1️⃣ 전역 **실행 컨텍스트** 생성하여, <u>실행 컨텍스트 스택</u>에 푸시한다!
2️⃣ 전역 **렉시컬 환경**을 생성하여, 1️⃣ <u>전역 실행 컨텍스트</u>에 바인딩한다!

> 전역 **렉시컬 환경**의 구성요소는 2가지이다.
> ** 3️⃣ 환경 레코드**(`Environment Record`) : 식별자, 식별자에 바인딩된 값 관리
> ** 7️⃣ 외부 렉시컬 환경에 대한 참조**(`Outer Lexical Environment Reference`) : 상위 코드의 렉시컬 환경(상위 스코프)을 가리킴.

3️⃣ 전역 **환경 레코드** 생성

> 전역 **환경 레코드**의 구성요소는 2가지이다.
> ** 4️⃣ 객체 환경 레코드**(`Object Environment Record`) : `var` 키워드로 선언한 전역 변수 + 전역함수 + 빌트인 전역 프로퍼티/함수 + 표준 빌트인 객체
> ** 5️⃣ 선언적 환경 레코드**(`Declarative Environment Record`) : `let`, `const` 로 선언한 전역 변수(개념적인 블록내에 존재)

4️⃣ **객체 환경 레코드** 생성 (in 3️⃣)

- `var` 키워드로 선언한 전역 변수 + 전역함수 + 빌트인 전역 프로퍼티/함수 + 표준 빌트인 객체
- 전역 객체(✨23.6.1에서 생성) `BindingObject`와 연결된다.
  - 즉, 이를 통해 전역 변수/전역 함수가 <u>전역 객체의 프로퍼티/메서드가 된다</u>
- `var` 키워드로 선언한 전역 변수는 선언/초기화 단계가 동시에 진행된다. 이에 암묵적으로 `undefined`가 바인딩된다.
  ![](https://velog.velcdn.com/images/pipi/post/80e542ff-d890-48cf-bc6a-50d95d36a566/image.png)

5️⃣ **선언적 환경 레코드** 생성 (in 3️⃣)

- `let`, `const` 로 선언한 전역 변수(개념적인 블록내에 존재) -> `window.y` 처럼 참조할 수가 없다.
- 🚨 일시적 사각지대
  - `let`, `const` 변수는 선언/초기화 단계가 분리되어 있는데, 선언~초기화 단계 사이에서는 실행 컨텍스트에 변수(`window.y`)는 등록되었으나, 메모리에 값이 할당되지 않아, 접근할 수 없다.

```js
let foo = 1; // 전역 변수

{
  // let, const 키워드로 선언한 변수가 호이스팅되지 않는다면 전역 변수를 참조해야 한다.
  // 하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다.
  console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
  let foo = 2; // 지역 변수
}
```

![](https://velog.velcdn.com/images/pipi/post/1c336ff7-fbc4-48c0-adcd-412cc9554309/image.png)

6️⃣ **this 바인딩**

- 3️⃣ 전역 **환경 레코드** 내부 슬롯 `[[GlobalThisValue]]` 에 `this`가 바인딩 된다.
- 일반적으로 전역 코드에서 `this`는 전역 객체이므로, 전역 객체가 바인딩된다.
  ![](https://velog.velcdn.com/images/pipi/post/1d9f1162-a40e-4f22-9cd8-3a0c4a308e3b/image.png)

7️⃣ 외부 렉시컬 환경에 대한 참조 결정

- 외부 소스코드의 렉시컬 환경(상위 스코프)를 가리킨다.
- 그러나 전역 코드를 포함하는 외부 소스코드는 없으므로 `null`이 할당된다. === 전역 렉시컬 환경이 스코프 체인의 종점이다!
  ![](https://velog.velcdn.com/images/pipi/post/31a74194-ac52-4d7c-a859-380aca94ecd9/image.png)

### ✨ 23.6.3 전역 코드 실행

- 변수 할당문이 실행되어 x,y 값이 할당된다.
- 이때, 어느 스코프에 식별자를 참조해야 하는지 **식별자 결정**이 일어난다.
- 식별자는 (실행 컨텍스트 - 렉시컬 환경 - 환경 레코드)에 등록되어 있으며, 만약 현재 실행 컨텍스트에 존재하지 않을 경우, <u>외부 렉시컬 환경에 대한 참조</u>가 가리키는 렉시컬 환경(상위 스코프)로 이동한다. => 🧩 **스코프체인의 동작 원리**

### ✨ 23.6.4 foo 함수 코드 평가

```js
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}

foo(20); // 42
```

- 1️⃣ 함수 실행 컨텍스트 생성
  - 2️⃣ 함수 렉시컬 환경 생성
    - 3️⃣ 함수 환경 레코드 생성
    - 4️⃣ this 바인딩
    - 5️⃣ 외부 렉시컬 환경에 대한 참조 결정

1️⃣ 함수 **실행 컨텍스트** 생성하여, <u>실행 컨텍스트 스택</u>에 푸시한다!
2️⃣ 함수 **렉시컬 환경**을 생성하여, 1️⃣ <u>foo 함수 실행 컨텍스트</u>에 바인딩한다!
3️⃣ 함수 **환경 레코드** 생성

- 매개변수, arguments 객체, 지역변수, 중첩 함수를 등록하고 관리한다.
  ![](https://velog.velcdn.com/images/pipi/post/d1d3446a-7214-41da-8757-26071377c591/image.png)

4️⃣ this 바인딩

- 함수 환경 레코드의 `[[ThisValue]]` 내부 슬롯에 `this`가 바인딩 된다. 이때, `this`에 무엇이 할당될지는 함수 호출 방식에 따라 결정된다([22장](https://velog.io/@pipi/%EB%AA%A8%EB%8D%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-22%EC%9E%A5#-222-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EB%B0%A9%EC%8B%9D%EA%B3%BC-this-%EB%B0%94%EC%9D%B8%EB%94%A9))

![](https://velog.velcdn.com/images/pipi/post/0a886287-06b6-476e-8e4b-b15e12412ee4/image.png)

5️⃣ 외부 렉시컬 환경에 대한 참조 결정

- 상위 스코프가 결정되는 방식은, 어디서 호출했는지가 아니라 어디서 정의했는지다.
- 즉, foo함수는 전역 코드에 정의된 함수이므로, 전역 렉시컬 환경의 참조가 할당된다!

![](https://velog.velcdn.com/images/pipi/post/6b0827bc-907e-4e96-a09f-9d9f49091e8b/image.png)

### ✨ 23.6.5 foo 함수 코드 실행

- 매개변수에 인수가 할당되고, 지역 변수 `x`, `y`에 값이 할당된다.(by 식별자 결정)

### ✨ 23.6.6 bar 함수 코드 평가

- ✨ 23.6.4와 같다.

### ✨ 23.6.7 bar 함수 코드 실행

- ✨ 23.6.5와 같으나, `console.log()`에 대해 더 설명한다.
- 1. console 식별자를 스코프 체인에서 검색 -> bar -> foo -> 전역 렉시컬 환경 `BindingObject` 에서 찾을 수 있다.
- 2. console 객체의 프로토타입 체인을 통해 메서드를 검색
- 3. 표현식 a + b + x + y + z의 평가 <- 각 변수는 스코프 체인을 통해 검색하고, 참조한다.
- 4. console.log 메서드에 값이 전달되어 호출한다.

### ✨ 23.6.8 bar 함수 코드 실행 종료

- 실행 컨텍스트 스택에서 **bar 함수 실행 컨텍스트**가 제거된다.
- 그러나, bar 함수 렉시컬 환경의 경우, 누가 참조하고 있다면 이는 소멸하지 않는다!

### ✨ 23.6.9 foo 함수 코드 실행 종료

- 실행 컨텍스트 스택에서 **foo 함수 실행 컨텍스트**가 제거된다.

### ✨ 23.6.10 전역 코드 실행 종료

- 실행 컨텍스트 스택에서 **전역 실행 컨텍스트**가 제거된다. 이제 스택에는 아무것도 없다!
