## 27장. ✨ 배열

### 📌 27-1. 배열이란?

배열은 `여러 개의 값을 순차적으로 나열한 자료구조`이다.

배열이 가지고 있는 값을 `요소`(element)라고 부르며, 자바스크립트의 모든 값은 배열의 요소가 될 수 있다.

배열의 요소는 배열에서 자신의 위치를 나타내는 0이상의 `인덱스`(index)를 갖는다.

배열은 기본적으로 길이를 나타내는 `length 프로퍼티`를 가진다.

인덱스와 length를 가지고 있기 때문에 값의 순서를 가지며, 순회가 가능하다는 특징이 있다.

---

### 📌 27-2. 자바스크립트 배열은 배열이 아니다.

자료구조에서 말하는 배열과 자바스크립트의 배열은 차이가 있다.

흔히, 자료구조에서 말하는 배열은 밀집 배열이다.

- 밀집 배열: 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료구조
  - 배열의 요소는 하나의 데이터 타입으로 통일됨
  - 배열의 요소들이 서로 연속적으로 인접해 있음
  - 각 요소들이 동일한 데이터 크기를 가짐

> **자바스크립트의 배열은 희소 배열을 허용**한다.

즉, 배열의 요소가 연속적으로 이어져 있지 않아도 되며(요소의 값이 존재하지 않는 경우) 배열의 요소마다 메모리 공간 또한 동일한 크기가 아닐 수 있다.(요소마다 데이터 타입이 달라도 허용)

이처럼 자바스크립트 배열은 일반적인 배열의 동작을 흉내낸 특수한 객체이다.

자바스크립트 배열은 해시 테이블로 구현된 객체이다.

일반적인 배열보다 인덱스로 요소에 접근시 성능적으로는 느리다는 단점이 존재하지만,
**요소를 삽입하거나 삭제하는 경우에는 일반적인 배열보다 빠른 성능**을 보인다.

모던 자바스크립트 엔진은 인덱스로 요소에 접근시 성능적으로는 느리다는 단점을 보완하기 위해 일반 객체와 구별하여 배열처럼 동작하도록 최적화를 구현했다.

---

### 📌 27-3. length 프로퍼티와 희소 배열

> length 프로퍼티는 요소의 개수(배열의 길이를 나타내는 0이상의 정수)를 값으로 갖는다.

빈 배열이 아닌 경우 가장 큰 인덱스에 + 1 을 한 것이 해당 배열의 length와 같다.

```js
// 가장 큰 인덱스는 1
const arr = [1, 2];

// 가장 큰 인덱스에 + 1을 한 값은 해당 배열의 length 이다.
arr.length === 2; // true
```

length프로퍼티의 값은 `배열에 요소를 추가하거나 삭제하면 자동 갱신`된다.

length에 직접적인 값 할당을 통해 원본 배열을 변경할 수 있다.

주의할 점은 현재 length보다 큰 값을 할당하는 경우 length의 값은 늘어나지만,
실제 배열에는 비어있는 값이 들어가게 된다.

```js
const arr = [1, 2, 3];

arr.length = 2;

console.log(arr); // [1, 2]

// 배열의 길이보다 큰 값을 할당할 경우
arr.length = 3;

// 희소배열이 됨
console.log(arr); // [1, 2, 비어 있음]
```

희소 배열은 length와 배열 요소의 개수가 일치하지 않으며, length는 희소배열의 실제 요소 개수보다 언제나 크다는 특징을 가진다.

배열을 생성할 경우, **희소배열을 생성하지 않도록 주의가 필요**하다.

(배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 최선의 방법)

---

### 📌 27-4. 배열 생성

#### 🔎 배열 리터럴

> 배열 리터럴은 가장 일반적으로 배열을 생성하는 방법이며, `[]` 대괄호 표기법을 사용한다.

만약 배열 리터럴에서 요소를 생략하면 희소배열이 생성된다.

```js
const arr = []; // []
const arr2 = [1, 2]; // [1, 2]
const arr3 = ["a", , "b"]; // ['a', empty,'b']
```

#### 🔎 Array 생성자 함수

> `new Array()` 생성자 함수는 전도된 인수의 개수에 따라 다르게 동작하며 배열을 생성한다.

- 전달된 인수가 1개의 숫자인 경우 : length 프로퍼티 값이 인수인 배열을 생성

```js
// 값이 비어있는 희소배열이 생성된다.
new Array(1); // [empty * 1]
new Array(10); // [empty * 10]
```

- 전달된 인수가 없는 경우 : 빈 배열을 생성한다.

```js
new Array(); // []
new Array(0); // []
```

- 전달된 인수가 2개 이상이거나 숫자가 아닌 경우: 인수를 요소로 갖는 배열을 생성한다.

```js
new Array(1, 2); // [1, 2]
new Array("a", "b"); // ['a', 'b']
new Array(1, "a"); // [1, 'a']
```

추가적으로 Array 생성자 함수는 `new` 연산자와 함께 호출하지 않아도 배열을 생성하는 생성자 함수로서 동작한다.

(생성자 함수 내부에서 `new.target`을 확인하기 때문)

#### 🔎 Array.of

> `Array.of()`메서드는 전달된 인수를 요소로 갖는 배열을 생성한다.

```js
// 전달된 인수가 1개이고 숫자여도 인수를 요소로 갖는 배열을 생성
Array.of(1); // [1]

Array.of(1, 2, 3); // [1,2,3]

Array.of("abc"); // ['abc']
```

#### 🔎 Array.from

> `Array.from()` 메서드는 유사배열 객체 or 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환한다.

- 유사배열 객체: 배열처럼 인덱스로 프로퍼티 값에 접근이 가능하며 `length 프로퍼티`를 갖는 객체를 말한다.

- 이터러블 객체: `Symbol.iterator` 메서드를 구현하여 `for ... of 문으로 순회 가능`하며, 스프레드 문법과 배열 디스트럭처링 할당의 대상으로 사용할 수 있는 객체를 말한다.

첫번째 인수에는 유사배열 객체 or 이터러블 객체가 들어가며, 두번째 인수에는 콜백함수를 통해 값을 만들면서 요소를 채울 수 있다.

```js
Array.from({ length: 3 }, (_, index) => {
	i;
}); // [0, 1, 2]
```

---

### 📌 27-5. 배열 요소의 참조

배열의 요소를 참조할 때에는 대괄호(`[]`)표기법을 사용한다.

대괄호 안에는 인덱스가가 와야하며, 정수로 평가되는 표현식이라면 인덱스 대신 사용할 수 있다.
(객체의 프러티 키와 같은 역할을 수행)

존재하지 않는 요소에 접근하는 경우 undefined가 반환된다.

```js
const arr = ["a", "b"];
const index = 0;

console.log(arr[0]); // 'a'
console.log(arr[1]); // 'b'
console.log(arr[index]); // 'a'
console.log(arr[2]); // undefined
```

---

### 📌 27-6.

---

### 📌 27-7.

---

### 📌 27-8.

---

### 📌 27-9. 배열 고차 함수

- 고차함수: 함수를 인수로 전달받거나 함수를 반환하는 함수를 말한다.

> `고차함수`는 `외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향`하는 함수형 프로그래밍에 기반을 둔다.

**순수 함수를 통해 부수 효과를 최대한 억제**하여 오류를 피하고 프로그램의 안정성을 높이려는 노력이다.

자바스크립트는 고차 함수를 다수 지원하며, 배열의 고차함수들은 활용도가 매우 높다.

<br>

#### 🔎 Array.prototype.sort

> sort 메서드는 배열의 요소를 정렬하며, `원본 배열을 직접 변경하여 정렬된 배열로 반환`한다.

기본적으로 `오름차순`으로 요소를 정렬한다.

내림차순으로 정렬하려면 sort 메서드를 사용하여 오름차순으로 정렬 후, reverse 메서드를 사용하여 요소의 순서를 뒤집는다.

문자열을 정렬할 때에는 유니코드 순으로 재정렬되기 때문에 문제가 없지만,
숫자타입의 값들을 정렬할 땐 문제가 발생한다.

이 경우에는 `정렬 순서를 정의하는 비교 함수를 인수로 전달`해야 한다.

- 오름차순 정렬: `sort((a, b) => a - b)`;
- 내림차순 정렬: `sort((a, b) => b - a)`;

```js
const arr = [1, 3, 0, 2, 5, 4];

arr.sort((a, b) => a - b); //  [0, 1, 2, 3, 4, 5]
arr.sort((a, b) => b - a); // [5, 4, 3, 2, 1, 0]

console.log(arr); //  [5, 4, 3, 2, 1, 0] 원본 배열이 변경됨
```

원본배열의 불변성을 유지하기 위해서는 주의가 필요하다.

```js
const arr = [1, 3, 0, 2, 5, 4];

// 스프레드를 사용하여 복사한 배열을 재정렬
[...arr].sort((a, b) => a - b); //  [0, 1, 2, 3, 4, 5]
[...arr].sort((a, b) => b - a); // [5, 4, 3, 2, 1, 0]

console.log(arr); // [1, 3, 0, 2, 5, 4] 원본 배열 유지
```

#### 🔎 Array.prototype.forEach

> forEach 메서드는 for 문을 대체할 수 있는 고차함수이다. 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출한다. (원본 배열은 변경되지 않음)

forEach 메서드의 반환값은 언제나 undefined이다.

forEach 메서드는 for문을 대체할 수 있지만, for 문과달리 `배열의 모든 요소를 빠짐없이 모두 순회`하며 `중간에 순회를 중단할 수 없다는 특징`이 있다. (for문은 continue, break를 통해 순회 중단 가능)

추가적으로, 희소 배열의 경우 `존재하지 않는 대상은 순회 대상에서 제외`한다.

```js
const arr = [1, 2, 3, 4, 5];

arr.forEach((value) => {
	console.log(value);
});
```

<br>

#### 🔎 Array.prototype.map

> map 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. `콜백 함수의 반환값들로 구성된 새로운 배열을 반환한다.` (새로운 배열을 반환하며, 원본 배열은 변경되지 않음)

map 메서드가 생성하여 `반환한 새로운 배열의 length 프로퍼티 값`은 map 메서드를 `호출한 배열의 length 프로퍼티 값과 반드시 일치한다.` (1:1로 매핑함)

- 첫번째 인수: 배열 요소의 값 (= item, = value)
- 두번째 인수: 배열 요소의 인덱스 (= index)
- 세번째 인수: this (= 호출한 배열 자체, = arr)

```js
const arr = [1, 2, 3];

const arr2 = arr.map((value, index, arr) => value * 2); // [2, 4, 6]
```

<br>

#### 🔎 Array.prototype.filter

> filter 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다. `콜백 함수의 반환값이 true인 요소로만 구성된 새로운 배열을 반환`한다.

filter 메서드가 생성하여 `반환한 새로운 배열의 length 프로퍼티 값`은 filter 메서드를 `호출한 배열의 length 프로퍼티 값과 같거나 작다`.

- 첫번째 인수: 배열 요소의 값 (= item, = value)
- 두번째 인수: 배열 요소의 인덱스 (= index)
- 세번째 인수: this (= 호출한 배열 자체, = arr)

```js
const arr = [1, 2, 3, 4, 5];

arr.filter((item, index, arr) => {
	return item % 2 === 0;
}); // [2, 4]
```

<br>

#### 🔎 Array.prototype.reduce

> reduce 메서드는 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달된 콜백 함수를 호출한다. `콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫번째 인수로 전달하면서 콜백함수를 호출하여 하나의 결과값을 만들어 반환한다.` (원본 배열은 변경되지 않음)

- 첫번째 인수: 콜백 함수 (= item, = value)
  - 콜백함수의 첫번째 인수: accumulator (= 합쳐져서 반환될 값)
  - 콜백함수의 두번째 인수: currentValue (= 현재의 요소)
  - 콜백함수의 세번째 인수: index (= 배열 요소의 인덱스)
  - 콜백함수의 네번째 인수: array (= 호출한 배열 자체, = arr)
- 두번째 인수: 초기값 (= index)

reduce 메서드는 활용도가 높다.

- 평균 구하기
- 최대값 구하기
- 요소의 중복 횟수 구하기
- 중첩 배열 평탄화
- 중복 요소 제거 등..

reduce 메서드를 호출할 때에는 `언제나 초기값을 전달하는 것이 안전`하다.

<br>

#### 🔎 Array.prototype.some

> some 메서드는 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출한다. 콜백 함수의 `반환값이 단 한번이라도 참이면 true, 모두 거짓이라면 false를 반환`한다.

some은 주로 콜백 함수를 통해 **정의한 조건을 만족하는 요소가 1개 이상 존재하는지 확인**할때 사용한다.

```js
const arr = [1, 2, 3, 11];

arr.some((num) => num > 10); // true
arr.some((num) => num < 0); // false
```

<br>

#### 🔎 Array.prototype.every

> every 메서드는 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출한다. 콜백 함수의 `반환값이 모두 참이면 true, 단 한번이라도 거짓이라면 false를 반환`한다.

every메서드를 호출한 배열이 빈배열일 경우, 언제나 true를 반환하므로 주의가 필요하다.

```js
const arr1 = [2, 4, 6, 8, 9, 10];
const arr2 = [2, 4, 6, 8, 10];
const arr3 = [];

arr1.every((value) => value % 2 === 0); // false
arr2.every((value) => value % 2 === 0); // true
arr3.every((value) => value % 2 === 0); // true
```

<br>

#### 🔎 Array.prototype.find

> find 메서드는 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 `반환값이 true인 첫 번째 요소를 반환`한다. (true인 요소가 존재하지 않으면 undefined를 반환)

```js
const users = [
	{ id: 1, name: "Lee" },
	{ id: 2, name: "Kim" },
	{ id: 3, name: "Han" },
	{ id: 4, name: "Kim" },
];

users.find((user) => user.name === "Kim"); // {id: 2, name: 'Kim'}
users.find((user) => user.name === "Choi"); // undefined
```

<br>

#### 🔎 Array.prototype.findIndex

> findIndex 메서드는 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 `반환값이 true인 첫 번째 요소의 인덱스를 반환`한다. (true인 요소가 존재하지 않으면 -1을 반환)

```js
const users = [
	{ id: 1, name: "Lee" },
	{ id: 2, name: "Kim" },
	{ id: 3, name: "Han" },
	{ id: 4, name: "Kim" },
];

users.findIndex((user) => user.name === "Kim"); // 1
users.findIndex((user) => user.name === "Choi"); // -1
```

<br>

#### 🔎 Array.prototype.flatMap

> flatMap 메서드는 map 메서드를 통해 생성된 새로운 배열을 평탄화한다.

즉, `map 메서드와 flat 메서드를 순차적으로 실행하는 효과`가 있다.

flatMap 메서드는 flat 메서드처럼 인수를 전달하여 평탄화 깊이를 지정할 수 없고 `1단계만 평탄화`한다.
(flat 메서드는 인수에 평탄화 깊이를 지정할 수 있음)

map 메서드를 통해 생성된 중첩 배열의 평탄화 깊이를 지정해야 하는 경우라면, map메서드와 flat메서드를 각각 호출해야한다.

```js
const arr = ["hi", "hello"];

const flatArr = arr.map((v) => v.split("")).flat(); // ['h', 'i', 'h', 'e', 'l', 'l', 'o']

const flatMapArr = arr.flatMap((v) => v.split("")); // ['h', 'i', 'h', 'e', 'l', 'l', 'o']
```
