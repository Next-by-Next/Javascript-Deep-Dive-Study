## 5.1 **값**

**표현식**이 평가되어 생성된 결과 

ex) 1+2; 1+2는 평가되어 값 3을 생성

변수에 할당되는 것은 값 ex) sum = 3

## 5.2 **리터럴**

사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 **값을 생성하는 표기법**

ex) 1001(정수 리터럴), null(null 리터럴), {name:”aa”}(객체 리터럴), function(){}(함수 리터럴)

## 5.3 **표현식**

(**값으로 평가될 수 있는 문** ⇒ 표현식이 평가되면, 값이 나옴)

**리터럴**은 값을 생성, 즉 **표현식**이다.

표현식은 리터럴, 식별자, 연산자등의 조합으로 이뤄질 수 있다.

ex) 100 **리터럴 표현식**

ex) sum 식별자 **표현식 == 변수도 표현식이다~~ 값을 나타낸다~ 이말이야~**

ex) 10 + 20 연산자 **표현식** (10+20은 결국 30이라는 값을 나타내기에)

ex) getSum() 함수호출도, 결국엔 값을 반환. 

## 5.4 **문**

프로그램을 구성하는 기본단위이자, 최소 실행 단위 (선언문, 할당문, 조건문, 반복문)

여러 *토큰*으로 구성됨, 토큰은 더이상 나눌수 없는 코드요소

ex) `var` `sum` `=` `1` `+` `2` `;` (토큰으로 이뤄짐)

ex) var x; 변수 선언**문**

ex) x = 5; 할당**문**

ex) if (x>1){} 조건**문**

⇒ **문**이 반드시 **표현식**이냐? 아닙니다~

## 5.5 **세미콜론** : **문**의 종료

`{ }` 코드블록의 경우, 세미콜론 안붙힘. 코드블록은 **자체 종결성**을 지님.

자바스크립트 엔진 → 세미콜론 자동 삽입 기능(ASI)때문에 생략가능하나, 붙히는걸 권장

## 5.6 **표현식인 문 VS 표현식이 아닌 문**

문 → 표현식인 문, 표현식이 아닌 문이 있음

⇒ 변수에 할당해서, 에러나면 표현식이 아닌 문! 에러 안나면 표현식인 문!

⇒ 왜? **표현식**은 값을 나타내기에!!

ex) var x = var x; 변수선언문을 할당함 ⇒ 표현식이 아닌 문

ex) var foo = x = 100; 할당문은 표현식인 문

### 개발자 도구

표현식이 아닌 문을 실행하면, undefinded출력

ex) `var foo = 100` (변수선언문) ⇒ undefinded

ex) `if (true) {}` ⇒ undefinded

표현식인 문 실행하면, **평가된 값 반환!**

ex) `var num = 10` ⇒ undefined

ex) `num + 100`   ⇒ 110

ex) `num = 100` (할당문)⇒ 100

ex) `num` ⇒ 100