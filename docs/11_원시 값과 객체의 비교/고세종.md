## 📕 오늘 공부한 내용 . ✒

**오늘 읽은 범위** : 11장

## 11. 원시 값과 객체의 비교

원시 값은 변경 불가능 한 값에 비해 객체는 변경 가능한 값이다.<br>
이에, 원시 값을 변수에 할당하면 변수에는 실제 값이 저장되지만, 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.

**값에 의한 전달** : 원시 값을 갖는 변수를 다른 변수에 할당, 값이 전달.<br>
**참조에 의한 전달** : 객체를 가르키는 변수를 다른 변수에 할당, 참조 값이 전달.

---

원시값은 변경 불가능한 값이다. <br>
우리는 4장 변수에서 변수에 값을 할당하면 메모리 공간에 값이 들어가고 그 메모리 공간을 가르키는 주소가 변수에 할당된다고 했다.<br>
그리고, 같은 변수에 다른 값을 재할당 할 경우, 메모리 공간에 있는 값이 바뀐느 것이 아닌, 다른 메모리 공간에 새로운 값이 저장되고, 새로운 메모리 공간의 주소가 변수에 다시 할당된다.

변수의 재할당이 이런 과정을 거치는 이유는 원시값은 변경 불가능한 값이기 때문이다.

---

## 값에 의한 전달

```javascript
let score = 80;
let copy = score;

console.log(score); // 80;
console.log(copy); // 80;

score = 100;

console.log(score); // 100;
console.log(copy); // 80;
```

위 예제를 통해 값에 의한 전달을 이해해보자.<br>
우선 `score`에 80을 할당하고, `copy`에 score를 할당했다.<br>

첫번째로 확인할 수 있는것은 score에 원시값인 80이 할당되어 있다는 것이다.<br>
즉, 2개의 메모리 공간에 80이라는 원시값이 각각 저장되고, score,copy라는 변수에 이 두개의 메모리 공간의 주소가 할당된다.<br>

그렇다면 score에 재할당을 했을경우는 어떻게 될까 ?<br>
`console.log()`로 결과를 확인했을때 score에 100이, copy에 80이 출력되는 이유는 각 메모리 공간에는 원시값이 저장되어 있기 때문이다.

---

## 참조에 의한 전달

객체는 변경 가능한 값이라고 했다.

> 객체는 크기가 원시값처럼 일정하지 않기때문에 재할당을 할경우 새로운 메모리 공간을 사용하기에 부담이 크다. 따라서 비용 절약을 위해 객체는 변경 가능한 값으로 설계되었다.

앞 단원에서 객체는 프로퍼티의 집합이라고 했다.<br>
따라서 객체가 생성되면 객체와 프로퍼티가 서로 다른 메모리 공간을 할당받고, 객체에는 프로퍼티의 메모리 공간 주소가 저장된다.<br>

이렇기 때문에 이미 생성된 객체를 다른 변수에 할당 했을 경우, 할당된 다른 변수의 메모리 공간에는 프로퍼티의 메모리 주소가 저장된다.

```javascript
const person = {
  name: 'sejong',
};

const copy = person;

person.name: 'sebellko';

console.log(person); // {name: 'sebellko'}
console.log(copy); // {name: 'sebellko'}
```

따라서 한 객체의 값을 변경 했을시 위와 같이 같은 프로퍼티가 의 주소가 저장된 모든 객체의 값이 변경되는 부작용이 발생한다.<br>
이에 자바스크립트에는 **참조에 의한 전달**은 존재하지 않고, **값에 의한 전달**만 존재한다.

#### +간결한 세 줄 요약
