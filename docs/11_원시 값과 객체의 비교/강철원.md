## 📕 오늘 공부한 내용, 이렇게 정리해 봅시다. ✒

**TIL(Today I learn) 기록일** : 2022.12.14

# 11장. 원시 값과 객체의 비교

- 자바스크립트가 제공하는 데이터 타입은 크게 원시 타입과 객체 타입 으로 구분할 수 있다.

	@@ -13,12 +13,12 @@
| 저장 내용 | 실제 값 저장 | 참조 값(메모리 주소) 저장 |
| 전달 방식 | 값에 의한 전달 | 참조에 의한 전달 |

## 원시 값

### 1) 변경 불가능한 값

- 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이다. (immutable value)
- 쉽게 말해 한번 생선된 원시 값은 읽기 전용 값으로서 변경할 수 없다. 이러한 원시 값의 특성은 데이터의 신뢰성을 보장한다.
- 그 전에 변수와 값을 명확히 구분해야한다.
  - 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름
  - 값   : 변수에 저장된 데이터로서 표현식이 평가되어 생성된 결과를 말한다.
	@@ -29,14 +29,43 @@
  이때 변수가 참조하던 메모리 공간의 주소가 바뀐다. 값의 이러한 특성을 불변성 이라고 한다.
- 불편성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.

### 2) 문자열과 불변성

- 문자열은 원시값이다. 
- 문자열은 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 각 문자에 접근할 수 있다.

```
<유사 배열 객체>
유사 배열 객체란 마치 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고 length 프로퍼티를 갖는 객체를 말한다.
문자열은 마치 배열처럼 인덱스를 통해 각 문자에 접근할 수 있으며, length 프로퍼티를 갖기 때문에 유사 배열 객체이고 for문으로 순회할 수도 있다. 
var str = 'string';
// 문자열은 유사 배열이므로 배열과 유사하게 인덱스를 사용해 각 문자에 접근할 수 있다.
console.log(str[0]); // s
// 원시 값인 문자열이 객체처럼 동작한다.
console.log(str.length); // 6
console.log(str.toUpperCase()); // STRING
```
- 주의 : str[0] = 'S' 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다.
        문자열은 변경 불가능한 값이기 때문이다.
        이처럼 한번 생성된 문자열은 읽기 전용 값으로서 변경할 수 없다.
        따라서 데이터의 신뢰성이 보장된다.
        항상 생각해야한다. 변수에 새로운 문자열을 재할당하는 것은 가능하지만 이는 기존 문자열을 변경하는 것이 아니라
        새로운 문자열을 새롭게 할당하는 것이다. 

###  3) 값에 의한 전달

- 엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라 메모리 주소가 전달되기에 값에 의한 전달은 모호한 표현이다. 
- 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
- 식별자로 값을 구별해서 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미한다.
  즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.

![image](https://user-images.githubusercontent.com/76567238/207576990-9a160d7d-b45a-4444-8f35-a8c69ae9b214.png)


```js
var score = 80;
	@@ -51,59 +80,38 @@ console.log(score); // 100
console.log(copy); // ???
```
저 물음표에 무엇이 출력될지 예상해보자 
![image](https://user-images.githubusercontent.com/76567238/207599250-836fc425-cb3b-47e9-b8e4-9ae081c52012.png)



  copy는 score로 부터 80이라는 값을 전달 받고 이것을 우리는 "값에 의한 전달" 이라고한다.   
  이때 전달받은 80이라는 값은 동일하지만 **그 값이 저장되는 메모리 저장 장소는 다르다.**   
  따라서 score = 100 으로 다시 재할당이 되어도 copy는 메모리 저장 장소가 다르기 때문에 영향이 없다 고로 ???는 여전히 80이다.   

여기서 메모리 저장 장소를 똑같게 할려면 어떻게 해야할까??

```js
var score ,copy = 80;
// 이렇게 하면된다   
// 여기서 score =100을 하면 score만 바뀐다   
console.log(copy); // ??? 
```

```
  만약 원시 값이 변경 가능한 값이라면 변수에 새로운 원시 값을 재할당했을 때 변수가 가리키던 메모리 공간의 주소를 바꿀 필요없이 원시 값 자체를 변경하면 그만이다.   
  만약 그렇다면 변수가 참조하던 메모리 공간의 주소는 바뀌지 않는다. 하지만 원시 값은 변경 불가능한 값이기 때문에 값을 직접 변경할 수 없다.    
  따라서 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후,   
  변수가 참조하던 메모리 공간의 주소를 변경한다.  값의 이러한 특성을 불변성이라 한다.
```

*중요한 것은 변수에 원시 값을 갖는 변수를 할당하면 변수 할당 시점이든, 두 변수 중 어느 하나의 변수에 값을 재할당하는 시점이든    
 결국은 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 간섭할 수 없다는 것이다.*

---

### 객체

- 객체는 원시 값과 같이 확보해야 할 메모리 공간의 크기를 사전에 정해 둘 수 없다.

- 자바스크립트 객체의 관리 방식
```
자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시 테이블이라고 생각할 수 있다.
대부분의 자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다.
자바, c++ 같은 클래스 기반 객체지향 프로그래밍 언어는 사전에 정의된 클래스를 기반으로 객체(인스턴스)를 생성한다. 
다시 말해, 객체를 생성하기 이전에 이미 프로퍼티와 메서드가 정해져 있으며 그대로 객체를 생성한다.'객체가 생성된 이후에는 프로퍼티를 삭제하거나 추가할 수 없다.
이는 사용하기 매우 편리하지만 성능 면에서는 이론적으로 클래스 기반 객체지향 프로그래밍언어의 객체보다 생성과 프로퍼티 접근에 비용이 더 많이 드는 비효율적인 방식이다.
따라서 V8 자바스크립트 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스라는 방식을 사용해 C++객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.
히든 클래스는 자바와 같이 고정된 객체 레이아웃(클래스)과 유사하게 동작한다.
```

#### 변경 가능한 값

- 메모리를 효율적으로 사용하기위해 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 변경 가능한 값으로 설계되어있다.

#### 참조에 의한 전달

- 얕은 복사라고도 한다. 


```js
var person = {
 name: "Lee"
};

// 참조 값을 복사(얕은 복사)
var copy = person;


copy.name = "KIM";

person.address = "Soul";

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다. 
console.log(person); // {name: "Kim", address: "Seoul"}
console.log(copy); // {name: "Kim", address: "Seoul"}
```

---

## 추가 블로그 정리

[원시타입과 객체타입](https://html-jc.tistory.com/499)

