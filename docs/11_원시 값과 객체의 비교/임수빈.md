# 🗓DAY12 - 원시 값과 객체의 비교

---

## 💭원시 값과 객체의 비교

데이터 타입의 구분

1. 원시타입

- 변경 `불가능한` 값
- 변수에 할당시 `실제값`이 저장된다 그러므로 `값에 의한 전달`이 일어남

2. 객체타입

- 변경 `가능한` 값
- 변수에 할당시 `참조값`이 저장된다 그러므로 `참조에 의한 전달`이 일어남

---

## 💭원시 값

한번 생성된 원시 값은 `readonly`로 값 변경이 불가 하다

여기서 변경이 불가한건 변수가 아닌 `값`에 대한 진술이다. 즉 원시값에서 재할당을 하면 새로운 메모리 공간을 확보하고 재할당된 원시 값을 저장후 변수는 새롭게 재할당한 원시 값을 가르키는 것이다.

그럼 상수는(const)?

- 변경 불가능이 아니라 재할당이 금지된 변수일뿐.

즉 원시값은 `메모리 공간의 주소`를 바꾼다는 뜻
이때 메모리 주소 공간을 변경하는 특징을 `불변성`이라고 한다.

불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경 할 수 있는 방법이 없다.

#### 값에 의한 전달

```
var score = 80;
var copy = score;

console.log(score); // 80
console.log(copy): //80

score = 100;

console.log(score); //100
console.log(copy) //80
```

1. score 의 80을 할당한 메모리가 생성된다.
2. score의 값을 값에의한전달로 80을 새로운 메모리에 할당한다.
3. score = 100 은 새로운 메모리를 생성해 100을 재할당하는것
4. 그럼 score이 100이더라도 copy는 변한게 없으므로 계속 80이 되는것임.

즉 두 변수의 원시 값은 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 값을 변경하더라도 서로 `간섭할 수 없다`

---

## 💭객체

객체는 동적으로 프로퍼티 생성이 가능하기 때문에 메모리 크기를 사전에 정해 둘 수 없다.

원시값을 할당한 변수를 참조하면 메모리에 저장되어 있는 원시 값에 접근한다. 하지만 객체를 할당한 변수를 참조하면 메모리에 저장되어있는 참조 값을 통해 `실제 객체`에 접근 한다.

```
var person = {
    name: 'Lee'
};

var copy = person; //얕은 복사 일어남
```

이때 person과 copy는 메모리 주소는 다르지만 동일한 객체를 가리킨다. 즉 `두개의 식별자가 하나의 객체를 공유한다는점` 어느 한쪽이라도 객체의 프로퍼티값을 변경하면 나머지 객체또한 영향을 받는다.

---
