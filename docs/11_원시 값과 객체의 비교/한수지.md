## 📌 원시값과 객체의 비교

자바스크립트의 데이터 타입은 `원시 타입`과 `객체 타입`으로 구분할 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/09cca03d-f640-44bc-a387-9c7c63689769/image.png)

- 원시 타입의 값 (= 원시값) : 변경 불가능한 값
- 객체(= 참조) 타입의 값 : 변경 가능한 값

**원시 값**을 변수에 할당하면 변수(확보된 메모리 공간)에는 **실제 값이 저장**된다.

![](https://velog.velcdn.com/images/ninto_2/post/c9dc0e05-7975-46d2-baf8-8e4b370314e5/image.png)

▲ 메모리 공간에 저장되는 실제 값의 예시

반면, 객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 **참조 값이 저장**된다.

![](https://velog.velcdn.com/images/ninto_2/post/944e994e-7281-4943-996e-76b85fc13b21/image.png)

▲ 메모리 공간에 저장되는 참조 값의 예시

- 값에 의한 전달 (call by value) : 원시 값을 갖는 변수를 다른 변수에 할당하면, 원본의 원시 값이 복사되어 전달된다.

- 참조에 의한 전달 (call by reference) : 객체를 가리키는 변수를 다른 변수에 할당하면, 원본의 참조 값이 복사되어 전달된다.

---

### 📌 원시값

#### 변경 불가능한 값

> `원시 타입`(primitive type)의 값, (= 원시값)은 `변경 불가능한`(immutable) 값이다.

`원시값`은 한번 생성되면 **읽기 전용 값**으로서, **변경 할 수 없다는 특징**을 갖는다.
(변경 불가능하다는 것은 변수가 아니라 값에 대한 진술이다.)

![](https://velog.velcdn.com/images/ninto_2/post/8a1edcce-c763-41ed-b08d-55f33c4d86c1/image.png)

▲ 원시값의 불변성

값이 할당되는 과정을 살펴보면, 해당 값은 원시값이기 때문에 죽지 않고 계속 살아있으며 변수의 메모리 주소가
바뀌는 것을 살펴볼 수 있다.

위와 같은 원시값의 특징을 **불변성(immutability)** 이라고 한다.

불변성을 갖는 원시 값을 할당한 변수는 `재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.`

#### 문자열과 불변성

앞서 예시를 들었던 숫자타입뿐만 아니라, 문자열(String type) 또한 원시값이다.

> **문자열**은 `유사 배열 객체`이면서 `이터러블`이다. (= 배열과 유사하게 각 문자에 접근가능)

- **유사 배열 객체**: 배열처럼 인덱스로 프로퍼티 값에 접근할 수 있고, **length 프로퍼티를 갖는 객체**이다.

#### 값에 의한 전달 (call by value, pass by value)

![](https://velog.velcdn.com/images/ninto_2/post/6123728e-3e98-42dd-b127-f945f1fd4e3e/image.png)

```js
let score = 80;
let copy = score;

score = 100;

console.log(score); // 100 재할당으로 값이 100으로 변경
console.log(copy); // 80 변경되지 않음
```

엄격하게 표현하면 변수에는 값이 전달되는 것이 아니라, **메모리 주소가 전달**된다.
변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

단, 전달된 메모리 주소를 통해 메모리 공간에 접근하면 값을 참조할 수 있다.

결과적으로 값에 의한 전달을 하면, 서로 다른 메모리 공간에 저장된 별개의 값이 되어 어느 한쪽에서 재할당을 통해 **값을 변경하더라도 서로 간섭할 수 없다.**

---

### 📌 객체

#### 자바스크립트 객체의 관리 방식 (= 해시 테이블과 유사)

자바스크립트 엔진은 해시 테이블과 유사하지만 높은 성능을 위해 더 나은 방법으로 객체를 구현한다.

![](https://velog.velcdn.com/images/ninto_2/post/9d7f7fce-87d8-4c09-8e9b-d72c88f5ffb9/image.png)

▲ 해시 테이블

key에서 buckets를 찾는 과정을 해싱이라고 한다.
해시 테이블은 `시간복잡도 O(1)`에 꺼내올 수 있다.

#### 변경 가능한 값

> 객체(참조) 타입의 값은 **변경 가능한 값**이다. (= 객체는 변경가능하다.)

![](https://velog.velcdn.com/images/ninto_2/post/944e994e-7281-4943-996e-76b85fc13b21/image.png)

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면, 참조 값에 접근할 수 있다.
즉, **재할당 없이 프로퍼티를 동적**으로 추가할 수 있고, 프로퍼티 값을 갱신 및 삭제할 수 있다.

(여러개의 식별자가 하나의 객체를 공유할 수 있음)

#### 얕은 복사와 깊은 복사

![](https://velog.velcdn.com/images/ninto_2/post/07a76b1b-2f4c-4184-907b-bb3a98fd9688/image.png)

객체를 프로퍼티 값으로 갖는 객체의 경우,

- 얕은복사의 경우, 한 단계까지만 복사된다.
- 깊은복사의 경우, 객체의 중첩되어 있는 객체까지 모두 복사된다.

```js
const v = 1;
const c1 = v;

console.log(c1 === v); // true 깊은 복사

const obj = { x: 1 };
const c2 = obj;

console.log(c2 === obj); // true 얕은 복사
```

[참고하면 좋은 링크: 얕은복사와 깊은복사](https://www.digitalocean.com/community/tutorials/copying-objects-in-javascript)

#### 참조에 의한 전달

참조에 의한 전달은 참조 값이 복사되어 전달된다.

![](https://velog.velcdn.com/images/ninto_2/post/e58469bb-cf22-4c4a-80b6-8e337e35872d/image.png)

위 그림과 같이, 주소값이 복사된다.

> 자바스크립트에는 참조에 의한 전달은 존재하지 않고, 값에 의한 전달만이 존재한다고 말할 수 있다.

![](https://velog.velcdn.com/images/ninto_2/post/04ffbb3d-01b4-4118-ad5a-6ad2e2bd89c7/image.png)

값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서,
전달한다는 면이 동일하기 때문이다.

---
