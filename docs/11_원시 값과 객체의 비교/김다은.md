# 11장 원시 값과 객체의 비교

## 원시 값

### 1. 불변성

원시 값은 변경 불가능한 값이다. **한번 생성된 원시 값은 읽기 전용 값**으로서 변경할 수 없다. 이러한 원시값의 특성은 **데이터의 신뢰성을 보장**한다. 원시 값을 할당한 변수에 새로운 원시 값을 재할당하면, 새로운 메모리 공간을 확보하고 재할당한 값을 저장한 후, 변수는 새롭게 재할당 원시 값을 가리킨다.  
이렇듯 변경 불가능한 값의 특성을 **불변성**이라고 한다. 불변성을 갖는 원시 값을 할당한 변수는 **재할당 이외에 변수 값을 변경할 수 있는 방법이 없다**.

### 2. 문자열과 불변성

원시 값인 문자열은 몇 개의 문자로 이루어졌느냐에 따라 필요한 메모리 공간의 크기가 결정된다.  
문자열은 유사 배열 객체이면서 이터러블이므로 인덱스로 각 문자에 접근할 수 있다. 하지만 이 값 또한 읽기 전용 값으로서 변경되지 않으며 이는 데이터의 신뢰성을 보장한다.

### 3. 값에 의한 전달

> 변수에 변수를 할당했을 때 무엇이 어떻게 전달되는가?

```js
var score = 80;
var copy = score;
```

변수에 원시 값을 갖는 변수를 할당하면 할당 받는 변수에는 **할당되는 변수의 원시 값이 복사되어 전달**된다. 이를 **값에 의한 전달**이라 한다. 하지만 score 변수와 copy 변수의 값 80은 **다른 메모리 공간에 저장된 별개의 값**이다.  
그 증거로 score의 값을 바꿔도 copy 값이 변하지 않는다는 것이 있다.

> 참고로 값에 의한 전달이라는 용어는 자바스크립트를 위한 용어가 아니므로 오해가 생길 수도 있다. 자바스크립트에서 위의 상황에선 **값이 전달되는 것이 아닌, 메모리 주소가 전달**된다. 변수와 같은 식별자는 값이 아니라 메모리 주소를 기억하고 있기 때문이다.

## 2. 객체

객체는 원시 값과 다르게 확보해야 할 메모리 공간의 크기를 사전에 정해둘 수 없다. 따라서 객체는 원시 값과는 다른 방식으로 동작하도록 설계되어 있다.

자바스크립트 객체는 프로퍼티 키를 인덱스로 사용하는 해시테이블이라고 생각할 수 있다. 하지만 대부분의 자바 스크립트 엔진은 성능을 위해 일반적인 해시 테이블보다 나은 방법으로 객체를 구현한다.  
V8 엔진에서는 프로퍼티에 접근하기 위해 동적 탐색 대신 히든 클래스라는 방식을 사용해 C++ 객체의 프로퍼티에 접근하는 정도의 성능을 보장한다.

### 1. 변경 가능한 값

객체를 할당한 변수가 식별자를 이용해 기억하는 메모리 공간에 접근하면 **참조 값에 접근**할 수 있다. **참조 값은 생성된 객체가 저장된 메모리 공간의 주소, 그 자체다.**

원시 값은 변경 불가능한 값이므로 값을 변경하려면 메모리에 원시 값을 새롭게 생성해야 한다. 하지만 객체는 변경 가능한 값이므로 메모리에 저장된 객체를 직접 수정할 수 있다. 이때 **객체를 할당한 변수의 참조 값은 변경되지 않는다**.

왜 이렇게 설계되어 있을까? 객체를 생성하고 관리하는 방식은 매우 복잡하며 비용이 많이 드는 일이다. 객체는 크기가 매우 클 수도 있고, 원시 값처럼 크기가 일정하지도 않으며, 프로퍼티의 값이 객체일 수도 있어서 복사해서 생성하는 비용이 많이 든다.

이러한 특성은 **여러 개의 식별자가 하나의 객체를 공유할 수 있다**는 부작용이 있다.

### 2. 참조에 의한 전달

객체를 가리키는 변수에 다른 변수를 할당하면, 원본의 참조 값(객체가 저장된 메모리의 주소값)이 복사되어 전달된다. 즉, **두 개의 식별자가 하나의 객체를 공유하게 되는 것**이다. 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경하면 서로 영향을 주고받는다.

결국 값에 의한 전달과 참조에 의한 전달은 **식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일**하다.

```js
var person1 = {
  name: 'Lee',
};

var person2 = {
  name: 'Lee',
};

console.log(person1 === person2); // false
```

두 객체를 비교하면 person1과 person2 안의 프로퍼티의 값은 같지만, 두 식별자가 가리키는 메모리에 저장된 참조 값은 다르기 때문에 false로 평가된다.
