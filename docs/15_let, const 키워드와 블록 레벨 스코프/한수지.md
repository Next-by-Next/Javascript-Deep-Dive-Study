## ✨ 15장. let, const 키워드와 블록 레벨 스코프

### 📌 15-1. var 키워드로 선언한 변수의 문제점

> 1. **변수의 중복을 허용한다.**

`var`키워드로 선언한 변수는 중복 선언이 가능하다.

```js
var x = 1;
var y = 1;

// 변수의 중복 선언
var x = 100;
var y;

console.log(x); // 100
console.log(y); // 1
```

다른 키워드라면 에러가 발생하는게 정상이지만,
`var`키워드로 선언한 변수를 중복 선언하면 초기화문 유무에 따라 다르게 동작한다.

변수의 중복을 허용한다는 것은, 의도치 않은 오류를 유발할 가능성이 크다.

> 2. **함수 레벨 스코프만을 인정한다.**

`var`키워드로 선언한 변수는 오직 `함수의 코드 블록만을 스코프로 인정`한다.

즉, 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 된다.

```js
var num = 1;

if (true) {
	var num = 10;
}

// 의도치 않게 변수값이 변경됨
console.log(num); // 10
```

함수레벨 스코프는 전역 변수를 남발할 가능성이 높이기 때문에, 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다.

> 3. **변수의 호이스팅**

자바스크립트는 ES6에 도입된 모든 선언을 호이스팅한다.

하지만, 다른 키워드로 선언한 변수와는 다르게 var로 선언한 변수는 호이스팅시 에러가 발생하지 않는다.

![](https://velog.velcdn.com/images/ninto_2/post/2bbf374f-cbce-448d-b055-8093d790332c/image.png)

```js
// 원래 에러가 발생해야하지만, var로 선언하였기 때문에 undefined가 나옴
console.log(num); // undefined

// 변수에 값을 할당
num = 123;

console.log(num); // 123

// 변수의 선언, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행됨
var num;
```

이는, 코드의 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.

> 따라서, `var`키워드로 변수를 선언하는 것은 지양해야 한다.

---

### 📌 15-2. let 키워드

- **let 키워드가 가진 특징**

> 1. **변수 중복 선언이 금지된다.**

`let` 키워드는 아래와 같이 변수의 중복 선언을 금지한다.

만약 그렇지 않은 경우 에러가 발생한다.

```js
let foo = "kim";

// 변수가 중복선언되면 에러가 발생
let foo = "han"; // SyntaxError
```

> 2. **블록 레벨 스코프를 가진다.**

![](https://velog.velcdn.com/images/ninto_2/post/6b8e4454-51db-4000-98cf-5294434282f5/image.png)

`let`으로 선언된 변수는 블록 레벨 스코프를 따른다.

만약 함수에서 선언된 경우 코드 블록이므로 스코프를 만들며, 함수 내의 코드 블록은 함수 레벨 스코프에 중첩된다.

> 3. **변수 호이스팅이 발생하지 않는 것처럼 동작한다.**

`let`으로 선언된 변수는 마치 호이스팅이 발생하지 않는 것처럼 동작한다.

하지만, `자바스크립트는 ES6에 도입된 모든 선언을 호이스팅한다.`

![](https://velog.velcdn.com/images/ninto_2/post/a229fcdb-a574-4cce-8bf2-b64850889a82/image.png)

- 일시적 사각지대: 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

> 4. **전역 객체와 let**

`var`키워드로 선언한 전역 변수와 전역함수, 선언하지 않은 변수에 값을 할당한 **암묵적 전역**은 전역 객체 `window`의 **프로퍼티**가 된다.

`let`키워드로 선언한 전역 변수는 **전역 객체의 프로퍼티가 아니다.** (`var`로 선언해야만 전역 객체의 프로퍼티가 된다.)

let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드)에 존재하게 된다.

---

### 📌 15-3. const 키워드

- **const 키워드가 가진 특징**

> 1. **선언과 동시에 초기화해야 한다.**

`const`키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.

만약 그렇지 않은 경우 에러가 발생한다.

```js
// 선언과 동시에 초기화
const num = 10; // 10

// 선언만 이루어져서 에러발생
const sum; // SyntaxError
```

const키워드로 선언한 변수는 let과 마찬가지로 **블록 레벨 스코프**를 가진다.

따라서, 변수 호이스팅이 발생하지 않은것 처럼 동작한다.

> 2. **재할당이 금지된다**

`const`키워드로 선언한 변수는 재할당이 금지되며, 재할당이 일어날 경우 에러가 발생한다.

```js
// 선언과 동시에 초기화
const num = 1;

// 재할당이 이루어져서 에러발생
num = 2; // TypeError
```

> 3. **상수를 표현할 수 있다.**

`const`키워드로 선언한 변수는 재할당이 금지되므로, 이러한 특징을 활용하여 상수를 표현하는데 사용하기에 유용하다.

- 상수: 재할당이 금지된 변수

상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다.

```js
// 파스칼 케이스로 상수를 표현함
const TAX_RATE = 0.1;
```

> 4. **const 키워드와 객체**

`const`키워드로 선언된 변수에 원시 값을 할당한 경우 값을 변경할 수 없다.

하지만, `const`키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있다.

```js
// const로 객체를 선언한 경우
const person = {
	name: "Han",
};

// 객체의 값을 재할당하여 변경
person.name = "Kim";
```

위 처럼, **const 키워드는 재할당을 금지할뿐, 불변을 의미하지는 않는다.**

만약 변경되지 않는 객체 값이 필요하다면 별도로 불변성을 고려해주어야 한다.

---

### 📌 15-4. var vs. let vs. const 키워드

> 변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다.

**권장되는 사용방법**

- ES6를 사용한다면 `var`키워드는 사용하지 않는다.
- 재할당이 필요한 경우에 한정해 `let`키워드를 사용한다. (이때, 변수의 스코프는 최대한 좁게 만든다.)
- 변경이 발생하지 않고, 읽기 전용으로 사용하는 (재할당이 필요없는 상수)원시값과 객체에는 `const`키워드를 사용한다. (재할당을 금지하므로 다른 키워드보다 안전하다.)
