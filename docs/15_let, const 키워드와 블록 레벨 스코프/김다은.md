# let, const 키워드와 블록 레벨 스코프

## var 키워드로 선언한 변수의 문제점

### 1. 변수 중복 선언 허용

변수를 중복선언하면서 값까지 할당했다면 **의도치 않게 먼저 선언된 변수 값이 변경되는 부작용**이 발생한다.

### 2. 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 따라서 **함수 외부에서 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수**가 된다.

### 3. 변수 호이스팅

var 키워드로 변수를 선언하면 호이스팅에 의해 변수 선언문 이전에 참조할 수 있다. 호이스팅은 에러를 발생시키지는 않지만 프로그램 흐름상 맞지 않을뿐더러 **가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다**.

## let 키워드

ES6에서 새롭게 도입된 키워드 중 하나다.

### 1. 변수 중복 선언 금지

let 키워드로 이름이 같은 **변수를 중복 선언하면 문법 에러가 발생**한다.

### 2. 블록 레벨 스코프

함수의 코드 블록만을 지역 스코프로 인정하는 var와는 다르게 let 키워드로 선언한 변수는 **모든 코드 블록(if, for, while 등)을 지역 스코프로 인정**하는 **블록 레벨 스코프**를 따른다.

### 3. 변수 호이스팅

let 키워드로 선언한 변수도 여전히 호이스팅이 적용되지만, var 키워드와 다르게 선언 단계와 초기화 단계가 분리되어 진행되기 때문에 초기화가 실행되기 이전에 변수에 접근하려고 하면 참조 에러를 발생한다.

```js
let foo = 1;

{
  console.log(foo); // ReferenceError
  let foo = 2;
}
```

만약 호이스팅이 발생하지 않는다면 전역 변수 foo에 접근해 에러가 발생하지 않을텐데 블록 스코프 내에서 let으로 선언한 변수에 호이스팅이 발생되었기 때문에 TDZ(Temporal Dead Zone)에서 참조한 것으로 되어 에러가 발생하는 것이다.

### 4. 전역 객체와 let

var 키워드로 선언한 전역 변수와 함수는 전역 객체 window의 프로퍼티가 되었다. 반면 let 키워드로 선언한 변수는 전역 객체의 프로퍼티가 아니다. let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드)안에 존재하게 된다.

## const 키워드

const는 let과 대부분 동일하다. 아래 내용은 let 키워드와 다른 점이다.

### 1. 선언과 초기화

**const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 한다.** 그렇지 않으면 문법 에러가 발생한다.

### 2. 재할당 금지

const로 선언한 변수는 **재할당이 금지**된다.

```js
const foo = 1;
foo = 2;
```

### 3. 상수

const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다. 따라서 const는 상수를 선언할 떄 많이 사용된다.

```js
const TAX_RATE = 0.1;
let afterTaxPrice = preTaxPrice + preTaxPrice * TAS_RATE;
```

### 4. const 키워드와 객체

const에 원시값을 할당한 경우 값을 변경할 수 없지만, **객체를 할당한 경우엔 값을 변경할 수 있다**. const 키워드는 **재할당을 금지할 뿐 "불변"을 의미하지는 않는다**.

## `var` vs. `let` vs. `const`

변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많다. 따라서 변수를 선언할 때는 일단 const 키워드를 사용하자.
