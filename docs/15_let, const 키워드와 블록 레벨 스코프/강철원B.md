**TIL(Today I learn) 기록일** : 2023.11.20

# 15장. let, const 키워드와 블록 레벨 스코프

## 🥎 1. var 키워드로 선언한 변수의 문제점

ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것 입니다. 

### 1) 변수 중복 선언 허용

```js
  var x = 1;
  var y = 1;
  
  var x = 100;
  
  var y;
  
  console.log(x); // 100
  console.log(y); // 1
```
- 위 예제의 var 키워드로 선언한 x변수와 y변수는 중복 선언되었습니다.    
- 이처럼 var 키워드로 선언한 변수를 중복 선언하면 초기화문(변수 선언과 동시에 초기값을 할당하는 문) 유무에 따라 다르게 동작합니다.   
- 초기화문이 있는 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시됩니다. 이때 에러는 발생하지 않습니다.

### 2) 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정합니다.
  - 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됩니다. 
```js
var x = 1;
if(true) {
  var x = 10;
}

console.log(x); // 10
```

for 문의 변수 선언문에서 var키워드로 선언한 변수도 전역 변수가 된다.

```js
var i = 10;

for(var i = 0; i <5; i++){
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 i 변수의 값이 변경되었다.
console.log(i); // 5
```

- 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높입니다. 
- 이로 인해 의도치 않게 전역 변수가 중복 선어되는 경우가 발생합니다.

---

## 🥎 2. let 키워드

ES6에서는 새로운 변수 선언 키워드인 let과 const를 도입했습니다. 


### 1) 변수 중복 선언 금지
  var 키워드로 이름이 동일한 변수를 중복 선언하면 아무런 에러가 발생하지 않습니다. 
  하지만 let키워드로 이름이 같은 변수를 중복 선언하면 문법에러가 발생합니다.
  
### 2) 블록 레벨 스코프

  var키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하는 함수 레벨 스코프를 따릅니다.   
  하지만 let 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, while 문, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따릅니다.  
  
### 3) 변수 호이스팅

let키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작합니다.
  ```js
  console.log(foo); // ReferenceError: foo is not defined
  let foo
  ```
  
  - let 키워드로 선언한 변수는 '선언 단계'와 '초기화 단계'가 분리되어 진행됩니다.   

### 4) 전역 객체와 let 

var 키워드로 선언한 전역 변수와 전역 함수 그리고 선언하지 않은 변수에 값을 할당한 암묵적 전역은 전역 객체 window의 프로퍼티가 됩니다.      
    전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있습니다.
    
---



## 🥎 3. const 키워드   


const 키워드는 상수를 선언하기 위해 사용합니다.    

하지만 반드시 상수만을 위해 사용하지는 않습니다.    



 ### 1) 선언과 초기화
  const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 합니다.
  ```js
  // 올바른 예
  const foo = 1;
  
  // 잘못된 예
  const foo; // SyntaxError: Missing initializer in const declaration
  ```
  
const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며, 변수 호이스팅이 발생하지 않는 것처럼 동작합니다.
  ```js
  {
  // 변수 호이스팅이 발생하지 않는 것처럼 동작한다.
  console.log(foo);  // ReferenceError: cannot access 'foo' before initialization
  const foo = 1;
  console.log(foo); // 1
  }
  
  // 블록 레벨 스코프를 갖는다.
  console.log(foo); // ReferenceError: foo is not defined
  ```
  
  ### 2) 재할당 금지
  
var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지됩니다.


  ### 3) 상수
  
  const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값을 변경할 수 없습니다. 이러한 특징을 이용해 const 키워드를 상수를 표현하는 데 사용하기도 합니다.   
  변수의 상대 개념인 상수는 재할당이 금지된 변수를 말합니다. 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 합니다.   
  
  ```js
  // 세전 가격
  let preTaxPrice = 100;
  
  // 세후 가격
  // 0.1의 의미를 명확히 알기 어렵기 때문에 가독성이 좋지 않다.
  let afterTaxPrice = preTaxPrice + (preTaxPrice * 0.1);
  
  console.log(afterTaxPrice); // 110
  ```
  
여기서 세율은 고정된 값이여서 상수로 정의하면 값의 의미를 쉽게 파악할 수 있고 변경될 수 없는 고정값으로 사용할 수 있습니다.
 ```js
 const TAX_RATE = 0.1;
 
 // 세전 가격
 let preTaxPrice = 100;
 
 // 세후 가격
 let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);
 
 console.log(afterTaxPrice); // 110
 ```
 
 ### 4) const 키워드와 객체
 
const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있습니다.
 ```js
 const person = {
  name : 'Lee'
 };
 
 // 객체는 변경 가능한 값이다. 따라서 재할당 없이 변경이 가능하다.
 person.name = 'Kim'
 
 console.log(person); // {name: "Kim"}
 ```
 - const 키워드는 재할당을 금지할 뿐 "불변"을 의미하지는 않습니다.
 - 새로운 값을 재할당하는 것은 불가능하지만 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능합니다.
 - 객체가 변경되더라도 변수에 할당된 참조 값은 변경되지 않습니다.
 
