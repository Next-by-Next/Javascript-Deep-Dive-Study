## 📕 오늘 공부한 내용 . ✒

**오늘 읽은 범위** : 17장

## 17. 생성자 함수에 의한 객체 생성

객체를 생성하는 가장 간단한 방법으로 객체 리터럴을 사용하는 방법이 있었다.<br>
그러나 한가지 문제가 있는데 여러개의 객체가 동일한 메소드를 가질경우, 불필요한 코드의 중첩이 일어난다는 것이다.

이를 해결하기 위해 생성자 함수를 사용해 객체를 생성할 수 있다.

### 생성자함수

생성자 함수는 객체를 만들기 위한 템플릿, 즉 틀이라고 생각할 수 있으며, 클래스와 같은 역할을 한다.<br>
그렇기 때문에 구조가 같은 여러개의 객체를 간편하게 생성할 수 있다.

생성자 함수를 사용하는 방법은 함수를 호출할때 `new` 키워드를 앞에 붙여서 사용한다.

생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿으로 동작하여, 인스턴스를 생성하는 것과, 생성된 인스턴스를 초기화 하는 것이다.<br>
생성자 함수 내부에는 반환하는 코드가 보이지 않는데, 이는 자바스크립트 엔진의 암묵적인 처리를 통해 생성된 인스턴스를 반환한다.

1. **인스턴스 생성과 this 바인딩**

`new` 키워드를 사용해 생성자 함수를 호출할 경우, 암묵적으로 빈 객체가 생성되고, 이 생성된 빈 객체, 인스턴스는 `this`에 바인딩 된다.<br>
이 과정은 러타임 이전에 실행된다.

2. **인스턴스 초기화**

런타임 시점에 코드가 한줄씩 실행되어 this에 바인딩된 인스턴스를 초기화 한다.<br>
this에 바인딩된 인스턴스에 프로퍼티나 메서드를 추가하고, 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화한다.

3. **인스턴스 반환**

완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.<br>
만약 생성자 함수 내부에 다른 객체를 반환하는 문이 있을경우 다른 객체가 반환되며 원시값을 반환할경우 무시된다.

그러니 생성자 함수 내부에는 반환문을 사용하지 말아야 한다.

### non-constructor / constructor

함수 객체는 [[Call]] 과 [[Construct]] 내부 메소드를 가지고 있다.<br>
함수가 일반 함수로서 호출되면 내부 메서드 [[Call]]이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다.

하지만 모든 함수가 callable 함수로 [[Call]] 내부 메소드를 갖지만, [[Construct]] 내부 메소드를 갖는것은 아니다.

- constructor : 함수 선언문, 함수 표현식, 클래스

- non-constructor : 메소드, 화살표 함수

각각 위 처럼 구분할 수 있다.

> 메소드는 ES6의 메소드 축약 표현만 메소드로 인정된다.

생성자 함수에 new 키워드 없이 호출하게 되면 일반함수 처럼 동작해 undefined를 반환하며, 생성자 함수 내부의 this는 전역 객체를 가르키게 된다.<br>
또한, 일반 함수도 생성자 함수 처럼 new 키워드를 붙여 호출할 수 있는데, 이 경우에는 함수 내부에서 객체를 반환할 경우 해당하는 객체를 아닌 경우 빈객체를 반환한다.

일반적으로 이런 혼란을 방지하기 위해 생성자 함수는 파스칼 케이스로 작성하는 컨벤션을 지키고 있지만, 한가지 안전장치를 추가로 설정할 수 있다.

### new.target

함수 내부에서 `new.target`을 사용하면 new 연산자와 함께 생성자 함수로서 호출되었는지 확인할 수 있다.

**new 연산자와 함께 생성자 함수로서 호출되면 함수 내부의 new.target은 함수 자신을 가르킨다. 따라서 new 연산자 없이 일반 함수로서 호출된 함수 내보의 new.target은 undefined이 된다.**

#### +간결한 세 줄 요약
