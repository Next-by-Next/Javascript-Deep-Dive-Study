# 🗓DAY10 - 객체 리터럴

---

## 💭객체란?

자바스크립트는 객체(object) 기반의 프로그래밍 언어이며, 자바스크립트를 구성하는 거의 `모든 것`이 객체이다. 인스턴스를 위한 바탕이 되는 프로토타입, 배열, 함수 및 표준 내장 객체 등을 포함한다.

객체 리터럴은 단순한 구조부터 복잡한 객체까지 표현할 수 있는 구문으로, 객체의 선언과 동시에 프로퍼티나 메서드를 정의할 수 있다. 객체 리터럴은 중괄호 {}를 사용하여 표시되며, 내부에서는 키: 값 형태로 프로퍼티를 정의한다

```
var person = {
  name: 'Lee',
  age: 20

};
```

name이라는 프로퍼티에 'Lee'라는 값을 할당하고, age라는 프로퍼티에 숫자 20을 할당한다 이와 같이 객체 리터럴을 사용함으로써, 간편하게 객체를 생성하고 초기화할 수 있다.

함수는객체? 객체는 함수? 🤔

- 함수로 객체를 생성하기도 하고 함수 자체가 객체이다 그러므로 js에선 둘은 분리해서 생각할 수 없는 개념이다.

> 중요 포인트 🔎
> 프로퍼티: 객체의 상태를 나타내는 값
> 메서드: 프로퍼티를 참조하고 조작할수 있는 동작 like함수

---

## 💭객체 리터럴에 의한 객체 생성

c++나 자바같은 클래스기반 객체지향언어는 클래스를 사전에 정의하고 필요한 시점에 `new`연산자와 함께 생성자를 호출하여 `인스턴스`를 생성하는 방식으로 객체를 생성한다.

하지만

js는 `프로토타입`기반 객체지향 언어로서 다양한 객체 생성 방법을 지원한다

- 객체리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스

#### 객체리터럴

- 객체를 생성하기 위한 표기법 {} 중괄호 내에 0개이상의 프로퍼티를 정의한다.
- 객체리터럴의 중괄호는 코드블록을 의미하지 않으므로 세미콜론을 붙여야한다.

```
var person={
    name : 'LEE' //프로퍼티
    sayHeool:function(){
        //메소드
    }
};
```

변수에 할당되는 시점에 js엔진은 객체리터럴을 해석해 객체를 생성한다.

> 중요 포인트 🔎
> 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체
> 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법

---

## 💭프로퍼티

객체는 `프로퍼티`의 집합이며, 프로퍼티는 `키와 값`으로 구성된다.

```
var person={
    name : 'LEE', //key: name value: 'LEE'
    age : 25
};
```

프로퍼티는 `,`로 나열하고

- 키: 빈문자열을 포함하는 문자열 또는 심벌 값
- 값: 자바스크립트에서 사용할 수 있는 모든 값
  이 값들도 식별자 네이밍 규칙을 따라야지 불편함이 생기지 않는다.

또 프로퍼티 키를 동적으로 생성할 수 있다

```
var obj = {};
var key = 'hello';

obj[key]='world';

console.log(obj) // {hello:'world'}
```

키는 또한 중복되기때문에 맨 마지막 값으로 덮어씌어진다.

---

## 💭메서드

일반함수와 객체내부의 함수를 구분하기위해 `메서드`라고 통칭한다.

```
var circle={
    radius: 5,
   getDiameter: function(){
       return 2*this.radius;
   }
};
```

객체 메소드 내부에서 사용한 this는 그 객체를 나타내는 `참조변수`이다

---

## 💭프로퍼티 접근

1. 마침표 프로퍼티 접근 연산자
2. 대괄호 프로퍼티 접근 연산자

```
var person={
    name :'LEE'
};

person.name //마침표 프로퍼티 접근 연산자
person['name'] //대괄호 프로퍼티 접근 연산자
```

꼭 대괄호 연산자 안의 프로퍼티는 `''` 괄호로 감싸줘야지 js엔진이 식별자로 해석한다.

---

# 🗓DAY11 - 객체 리터럴[2]

---

## 💭프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 `재할당`을 하면 값이 갱신된다

```
var person = {
    name: 'Lee'
}

person.name='kim';
console.log(person); //{name:'kim'}
```

---

## 💭프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 `동적`으로 생성되고 추가된다.

```
var person = {
    name: 'Lee'
}

person.age = 20;
console.log(person); //{name:'Lee', age:20}
```

> 중요 포인트 🔎
> 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체
> 리터럴: 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법

---

## 💭프로퍼티 삭제

`delete`연산자로 프로퍼티를 삭제할 수 있다 하지만 존재하고있는 프로퍼티여야한다.

```
var person = {
    name: 'Lee'
}

person.age = 20;

delete person.age;
delete person.address;

consol.log(person); //{name:'Lee'}
```

---

## 💭ES6에서 추가된 객체 리터럴의 확장 기능

ES6에서는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다

1. 프로퍼티 축약 표현

```
//ES5
var x = 1, y = 2;
var obj = {
    x:x,
    y:y
};

console.log(obj); //{x:1,y:2}
```

```
//ES6
var x = 1, y = 2;
var obj = {x,y};

console.log(obj); //{x:1,y:2}
```

프로퍼티 값으로 변수를 사용하는 경우 변수 이름과 프로퍼티 키가 동일하다면 `프로퍼티 키`를 생략할 수 있다.

2. 계산된 프로퍼티 이름
   문자열 또는 문자열 타입 변환할 수 있는 값으로 평가되는 표현식은 프로퍼티 키를 `동적`으로 생성할 수 있다.

```
//ES5
var prefix = 'prop';
var i = 0;

var obj = {};

obj[prefix + '-' + ++i]=i;
obj[prefix + '-' + ++i]=i;
obj[prefix + '-' + ++i]=i;

console.log(obj); //{prop-1:1, preop-2:2, prop-3: 3}
```

```
//ES6
var prefix = 'prop';
var i = 0;

var obj = {
    [`${prefix}-${++i}`]: i,
    [`${prefix}-${++i}`]: i,
    [`${prefix}-${++i}`]: i
};

console.log(obj);
```

3. 메서드 축약 표현

ES5에서 메서드를 정의하려면 프로퍼티 값으로 함수를 할당한다.

```
//ES5
var obj = {
    name :'Lee',
    sayHi:function(){
        console.log('Hi!'+this.name);
    }
};

obj.sayHi(); //Hi! Lee
```

ES6에서는 메서드를 정의할 때 function 키워드를 생략한 축약 표현을 사용할 수 있다.

```
//ES6
var obj = {
    name :'Lee',
    sayHi(){
        console.log('Hi!'+this.name);
    }
};

obj.sayHi(); //Hi! Lee
```

---
