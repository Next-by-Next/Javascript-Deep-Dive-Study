# 10. 객체 리터럴

## 1. 객체란?

자바스크립트를 구성하는 거의 "모든 것"이 객체다. 원시값을 제외한 나머지 값은 모두 객체다.  
또한 원시 값은 변경 불가한 값(immutable value)이지만 객체 타입의 값, 즉 **객체는 변경 가능한 값(mutable value)**이다.

> 🔎 이것이 const로 선언한 객체 안의 값이 변경될 수 있는 이유다.

객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다. 프로퍼티 값에는 자바스크립트에서 사용할 수 있는 모든 값은 물론, 함수도 들어갈 수 있다. 단, 프로퍼티 값이 함수일 경우 일반 함수와 구분하기 위해 메서드라고 부른다.

<br/>

## 2. 객체 리터럴에 의한 객체 생성

자바스크립트는 **프로토타입 기반 객체지향 언어**로서 클래스 기반 객체지향 언어와는 달리 다양한 객체 생성 방법을 지원한다.

> **🔎 프로토타입 기반 객체지향 언어**  
> 프로토타입 기반 언어는 클래스 기반 언어에서 상속을 사용하는 것과는 다르게, 객체를 원형(프로토타입)으로 하는 복제 과정을 통해 객체의 동작 방식을 재사용 할 수 있게 한다.  
> 자바스크립트에서 객체는 원형 객체로부터 생성되며, 생성된 객체는 `__proto__`에 원형 객체에 대한 참조를 갖게 된다. 프로토타입 체인의 최상위 객체는 `Object.prototype`이다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

객체 리터럴은 객체를 생성하는 가장 일반적이고 간단한 방법으로, 중괄호`{...}` 내에 0개 이상의 프로퍼티를 정의한다. 객체 리터럴은 코드 블록이 아닌 값으로 평가되는 표현식이다. 따라서 닫는 중괄호 뒤에는 세미콜론을 붙여야 한다.

<br/>

## 3. 프로퍼티

> 객체는 프로퍼티의 집합이며, 프로퍼티는 키와 값으로 구성된다.

- 프로퍼티 키: 빈 문자열을 포함하는 모든 문자열 또는 심벌 값
- 프로퍼티 값: 자바스크립트에서 사용할 수 있는 모든 값

이때 프로퍼티 키는 네이밍 규칙을 준수하는 이름일 경우에 따옴표를 생략할 수 있다. **반대로 식별자 네이밍 규칙을 따르지 않는 이름에는 반드시 따옴표를 사용해야 한다**.

> **🔎 네이밍 규칙을 따라야 하는 이유?**  
> 식별자 네이밍 규칙을 준수한 이름과 준수하지 않는 이름을 함께 사용하면 따옴표가 제거되면서 의도치 않는 연산을 일으킬 수 있다.
>
> ```
> var person  {
>  firstName: 'hi',
>  'last-name': 'Lee', // 따옴표를 생략한 last-name은 -연산자가 있는 표현식으로 해석한다.
> }
> ```

대괄호 `[...]` 안에 묶으면 프로퍼티 키를 동적으로 생성할 수도 있다.

### Quiz

아래의 경우에서 `perosn.last-name`의 결과는 Node.js 환경에서는 ReferenceError, 브라우저 환경에서는 NaN이다. 왜일까?

```js
var person = {
  'last-name': 'Lee',
  1: 10
}

person.'last-name';
perosn.last-name;
```

일단 자바스크립트 엔진은 person.last를 평가해 undefined로 평가된다. 따라서 위 표현식은 `undefined - name`과 같이 취급된다. 이때 name이라는 식별자에 대한 선언이 없으므로 ReferenceError가 발생하는 것이다. 그런데 브라우저 환경에서는 name이라는 전역변수가 암묵적으로 존재하며, 기본값이 빈 문자열이기 때문에 `undefined - ''`가 되어 NaN이 반환된다.

<br/>

## 6. 프로퍼티 값 갱신

이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.

```js
var person = {
  name: 'Lee',
};

person.name = 'Kim';
```

### 7. 프로퍼티 동적 생성

존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.

```js
var person = {
  name: 'Lee',
};

person.age = 20;
```

### 8. 프로퍼티 삭제

`delete` 연산자는 객체의 프로퍼티를 삭제한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러 없이 무시된다.

```js
var person = {
  name: 'Lee',
};

person.age = 20;

delete person.age;
```

<br/>

### 9. ES6에서 추가된 객체 리터럴의 확장 기능

#### 1. 프로퍼티 축약 표현

> 변수 이름과 프로퍼티 키가 동일한 이름일 때 프로퍼티를 생략할 수 있다.

```js
let x = 1,
  y = 2;

// 축약 표현
const object = { x, y };
```

#### 2. 계산된 프로퍼티 이름

표현식을 사용해 프로퍼티 키를 동적으로 생성할 수 있다. 이를 계산된 프로퍼티 이름이라 한다.

```js
// ES5
var prefix = 'prop';
var i = 0;

obj[prefix + '-' + ++i] = i;
obj[prefix + '-' + ++i] = i;

// ES6
const obj = {
  [`${prefix}-${++i}`]: i,
  [`${prefix}-${++i}`]: i,
};
```

#### 3. 메서드 축약 표현

```js
// ES5
var obj = {
  name: 'Lee',
  sayHi: function () {
    console.log('hi' + this.name);
  },
};

// ES6
const obj = {
  name: 'Lee',
  // 메서드 축약 표현
  sayHi() {
    console.log('hi' + this.name);
  },
};
```

> 메서드 축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다. 이에 대해서는 26.2절에서 다룬다.
