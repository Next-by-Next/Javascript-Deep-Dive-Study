## 객체 리터럴

### 프로퍼티 값 갱신

```js
const person = {
	name: "foo",
};

// 프로퍼티가 존재하므로 해당 key에 맞는 value의 값이 갱신된다.
person.name = "boo";

console.log(person); // { name: 'boo'}
```

이미 존재하는 **프로퍼티에 값을 할당하면 해당 프로퍼티 값이 갱신**된다.

---

### 프로퍼티 동적 생성

만약 `존재하지 않는 프로퍼티에 값을 할당`하면, 프로퍼티가 **동적으로 생성되어 추가되고 프로퍼티 값이 할당**된다.

```js
const person = {
	name: "foo",
};

// 새로운 프로퍼티 생성및 값 할당
person.age = 20;

console.log(person); // { name: 'foo', age: 20}
```

---

### 프로퍼티 삭제

> `delete` 연산자는 **객체의 프로퍼티를 삭제**한다.

만약 존재하지 않는 프로퍼티를 삭제한다면, 아무런 에러 없이 무시된다.

---

### ES6에서 추가된 객체 리터럴의 확장 기능

ES6에서는 간편한 객체 리터럴의 확장 기능을 제공한다.

#### 프로퍼티 축약 표현

> 변수이름과 프로퍼티 키가 동일한 경우 **프로퍼티 키를 생략**할 수 있다. (프로퍼티 키는 변수 이름으로 자동 생성됨)

```js
const x = 1;
const y = 2;

// 프로퍼티 키 생략 가능
const obj = {
	x, // x = 1
	y, // y = 2
};
```

#### 계산된 프로퍼티 이름

> **프로퍼티 키를 동적으로 생성**할 수 있다.

```js
// 동적 프로퍼티 키 생성의 예시

const perfix = "prop";
const i = 0;
const obj = {};

// 계산된 프로퍼티 이름으로 동적 생성
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2}
```

추가적으로, ES6에서는 객체 리터럴 내부에서도 프로퍼티 키의 동적인 생성이 가능하다.

#### 메서드 축약 표현

ES6에서는 메서드를 정의할때 `function`키워드를 생략한 **축약 표현을 사용**할 수 있다.

```js
const obj = {
	name: "foo",

	say() {
		console.log(name);
	},
};
```

축약 표현으로 정의한 메서드는 프로퍼티에 할당한 함수와 다르게 동작한다. (딥다이브: 26.2절 메서드 참고)
