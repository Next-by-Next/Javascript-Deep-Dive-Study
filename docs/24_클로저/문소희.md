# 🚀 클로저

## 🔎 4. 클로저의 활용

> 클로저는 **상태<sup>state</sup>를 안전하게 변경하고 유지하기 위해** 사용한다. 다시 말해, 상태가 의도치 않게 변경되지 않도록 **상태를 안전하게 은닉<sup>information hiding</sup>하고 특정 함수에게만 상태 변경을 허용하기 위해** 사용한다.

외부 상태 변경이나 가변<sup>mutable</sup> 데이터를 피하고 불변성<sup>immutability</sup>을 지향하는 함수형 프로그래밍에서 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 적극적으로 클로저가 사용된다. ✨

```javascript
// 카운트 상태 변경 함수
const increase = (function () {
  // 카운트 상태 변수
  let num = 0;

  // 클로저
  return function () {
    // num: 0
    // 프로퍼티는 public하므로 은닉되지 않음
    increase() {
      return ++num;
    },
    decrease() {
      return num > 0 ? --num : 0;
    }
  };
})();

console.log(increase()); // 1
console.log(increase()); // 2

console.log(decrease()); // 1
console.log(decrease()); // 0
```

위 메서드의 increase, decrease 메서드의 상위 스코프는 _해당 메서드들이 평가되는 시점에 실행 중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경이다._ 따라서 언제 어디서 호출되든 상관없이 **즉시 실행 함수의 스코프 식별자를 참조 가능하다.**

위 예제를 생성자 함수로 표현하면 아래와 같다.

```javascript
const Counter = (function () {
  // ① 카운트 상태 변수 (생성자 함수 Counter가 생성할 인스턴스의 프로퍼티가 아닌 즉시 실행 함수 내에서 선언된 변수)
  let num = 0;

  function Counter() {
    // num이 Counter가 생성할 인스턴스의 프로퍼티라면 인스턴스를 통해 외부에서 접근 자유로운 public 프로퍼티가 됨
    // this.num = 0; // ② 프로퍼티는 public하므로 은닉되지 않음
  }

  // 클로저
  // num 변수의 값은 increase, decrease 메서드만 변경 가능
  Counter.prototype.increase = function () {
    return ++num;
  };

  // 클로저
  // num 변수의 값은 increase, decrease 메서드만 변경 가능
  Counter.prototype.decrease = function () {
    return num > 0 ? --num : 0;
  };

  return Counter;
})();

const counter = new Counter();

console.log(counter.increase()); // 1
console.log(counter.increase()); // 2

console.log(counter.decrease()); // 1
console.log(counter.decrease()); // 0
```

아래 예제에서 makeCounter 함수를 호출해 함수를 반환할 때 반환된 함수는 자신만의 독립된 렉시컬 환경을 가지기 때문에 카운트를 유지하기 위한 자유 변수 counter를 공유하지 않아 카운터의 증감이 연동되지 않는다.

```javascript
// 함수를 인수로 전달받고 함수를 반환하는 고차 함수
// 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환
function makeCounter(aux) {
  // 카운트 상태를 유지하기 위한 자유 변수
  let counter = 0;

  // 클로저를 반환
  return function () {
    // 인수로 전달받은 보조 함수에 상태 변경 위임
    counter = aux(counter);
    return counter;
  };
}

// 보조 함수
function increase(n) {
  return ++n;
}

// 보조 함수
function decrease(n) {
  return --n;
}

// 함수로 함수를 생성
// makeCounter 함수는 보조 함수를 인수로 전달받아 함수를 반환
const increaser = makeCounter(increase); // ①
console.log(increaser()); // 1
console.log(increaser()); // 2

// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않음
const decreaser = makeCounter(decrease); // ②
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

독립된 카운터가 아니라 연동하여 증감이 가능한 카운터를 만들려면 렉시컬 환경을 공유하는 클로저를 만들어야 한다. 이를 위해서는 makeCounter 함수를 두 번 호출하지 말아야 한다.

```javascript
// 함수를 반환하는 고차 함수
// 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환
const counter = (function () {
  // 카운트 상태를 유지하기 위한 자유 변수
  let counter = 0;

  // 함수를 인수로 전달받는 클로저 반환
  return function (aux) {
    // 인수로 전달받은 보조 함수에 상태 변경 위임
    counter = aux(counter);
    return counter;
  };
})();

// 보조 함수
function increase(n) {
  return ++n;
}

// 보조 함수
function decrease(n) {
  return --n;
}

// 보조 함수를 전달하여 호출
console.log(increaser()); // 1
console.log(increaser()); // 2

// 자유 변수 공유
console.log(decreaser()); // 1
console.log(decreaser()); // 0
```

## 🔎 5. 캡슐화와 정보 은닉

> 캡슐화<sup>encapsulation</sup>는 객체의 상태를 나타내는 **프로퍼티와** 프로퍼티를 참조하고 조작할 수 있는 동작<sup>behavior</sup>인 **메서드를 하나로 묶는 것을 말한다.** 캡슐화는 **객체의 특정 프로퍼티나 메서드를 감출 목적으로** 사용하기도 하는데 이를 정보 은닉<sup>information hiding</sup>이라 한다.

정보 은닉은 외부에 공개할 필요가 없는 구현의 일부를 외부에 공개되지 않도록 감추어 **적절치 못한 접근으로부터 객체의 상태가 변경되는 것을 방치해 정보를 보호하고, 객체 간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다.**

```javascript
const Person = (function () {
  let _age = 0; // private

  // 생성자 함수 (이미 종료되어 소멸한 즉시 실행 함수의 지역 변수 _age를 참조할 수 있는 클로저)
  function Person(name, age) {
    this.name = name; // public
    _age = age;
  }

  // 프로토타입 메서드 (이미 종료되어 소멸한 즉시 실행 함수의 지역 변수 _age를 참조할 수 있는 클로저)
  Person.prototype.sayHi = function () {
    console.log(`Hi! My name is ${this.name}. I am ${_age}.`);
  };

  // 생성자 함수 반환
  return Person;
})();

const me = new Person('Lee', 20);
me.sayHi(); // Hi! My name is Lee. I am 20.
console.log(me.name); // Lee
console.log(me._age); // undefined

const you = new Person('Kim', 30);
you.sayHi(); // Hi! My name is Kim. I am 30.
console.log(you.name); // Kim
console.log(you._age); // undefined

// Person.prototype.sayHi 메서드가 단 한 번 생성되는 클로저이기 때문에 _age 변수의 상태가 유지되지 않음
// Person.prototype.sayHi 메서드의 상위 스코프는 어떤 인스턴스로 호출하더라도 하나의 동일한 상위 스코프를 사용하기 때문
me.sayHi(); // Hi! My name is Lee. I am 30.
```

## 🔎 6. 자주 발생하는 실수

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  }; // ① 함수가 funcs 배열의 요소로 추가됨
}

// 이떄 반환 결과는 전역 변수 i를 참조해 0 1 2가 아닌 3이 출력됨
for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // ② 3 3 3 funcs 배열의 요소로 추가된 함수 순차적으로 호출
}
```

클로저를 사용해 수정한 바르게 동작하는 코드는 아래와 같다.

```javascript
var funcs = [];

for (var i = 0; i < 3; i++) {
  // ① 즉시 실행 함수는 전역 변수 i에 현재 할당되어 있는 값을 인수로 전달받아 매개변수 id에 할당한 후 중첩 함수를 반환하고 종료됨
  // 이때 즉시 실행 함수 매개변수의 id는 즉시 실행 함수가 반환한 중첩 함수의 상위 스코프에 존재
  // 즉시 실행 함수가 반환한 중첩 함수는 자신의 상위 스코프를 기억하는 클로저이고, id는 자유 변수가 되어 그 값이 유지됨
  funcs[i] = (function (id) {
    return function () {
      return id;
    };
  })(i);
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]());
}
```

ES6의 let 키워드를 사용하면 번거로움이 깔끔하게 해결된다! 👀 `let`이나 `const`를 사용하는 반복문은 **코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성해** 당시의 상태를 마치 스냅숏을 찍는 것처럼 저장한다.

단, 반복문의 코드 블록 내부에 함수 정의가 없는 반복문이 생성하는 새로운 렉시컬 환경은 반복 직후 아무도 참조하지 않기 때문에 가비지 컬렉션의 대상이 된다. 즉, 반복문의 코드 블록 내부에서 함수를 정의할 때 의미가 있다.

```javascript
const funcs = [];

for (let i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  };
}

for (let i = 0; i < funcs.length; i++) {
  console.log(funcs[i]()); // 0 1 2
}
```

또는 함수형 프로그래밍 기법인 고차 함수를 사용하는 방법이 있다.

```javascript
// 요소가 3개인 배열을 생성하고 배열의 인덱스를 반환하는 함수를 요소로 추가
// 배열의 요소로 추가된 함수들은 모두 클로저
const funcs = Array.from(new Array(3), (_, i) => () => i); // (3) [f, f, f]

funcs.forEach((f) => console.log(f())); // 0 1 2
```

## 👀 REFERENCE

모던 자바스크립트 Deep Dive 24장 클로저
