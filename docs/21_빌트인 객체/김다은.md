# 21장 빌트인 객체

## 1. 자바스크립트 객체의 분류

- 표준 빌트인 객체  
  ECMAScript 사양에 정의된 객체. 자바스크립트 실행환경과 관계없이 선언하지 않고 언제나 사용할 수 있다.
- 호스트 객체  
  자바스크립트 실행환경에서 추가로 제공하는 객체. DOM,BOM, Node.js 고유 API가 그 예다.

- 사용자 정의 객체  
  사용자가 직접 정의한 객체를 말한다.

<br/>

## 2. 표준 빌트인 객체

> ECMAScript 사양에 정의된 객체. 자바스크립트 실행환경과 관계없이 선언하지 않고 언제나 사용할 수 있다.

Math, Reflect, JSON을 제외하면 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 생성자 함수인 빌트인 객체는 **프로토타입 메서드**와 **정적 메서드**를 제공하고, 생성자 함수가 아닌 빌트인 객체는 정적 메서드만 제공한다.

```js
const numObj = new Number(1.5); // Number{1.5}

// toFIxed는 Number.prototype의 프로토타입 메서드다.
console.log(numObj.toFixed()); // 2

// isInteger는 Number의 정적 메서드다.
// 정적 메서드는 인스턴스 없이 호출할 수 있다.
console.log(Number.isInteger(0.5)); // false
```

<br/>

## 3. 원시값과 래퍼 객체

원시값이 있는데도 Number, String 같은 표준 빌트인 생성자 함수가 존재하는 이유가 뭘까?

**문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체(wrapper object)라고 한다(null, undefined 제외)**. 예를 들어 문자열에 대해 마침표 표기법으로 접근하면 그 순간 래퍼 객체인 String 생성자 함수의 인스턴스가 생성되고, 문자열은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
이렇게 되면 래퍼 객체인 String 객체는 프로토타입의 메서드를 상속받아 사용할 수 있게 된다.

래퍼 객체의 처리가 종료되면 해당 식별자는 원시값을 갖도록 되돌려지고 래퍼 객체는 가비지 컬렉션의 대상이 된다. 다음 예제를 살펴보자.

```js
const str = 'hello';

// 식별자 str은 래퍼 객체를 가리키게 된다.
// 래퍼 객체에 name 프로퍼티가 동적 추가된다.
str.name = 'Lee';

// 처리가 종료되면 str은 다시 원래의 문자열로 할당된다. 이때 임시 생성된 래퍼 객체는 가비지 컬렉션의 대상이 된다.

// name이 추가된 래퍼 객체는 이미 연결이 끊겼으므로 name 프로퍼티가 존재하지 않는다고 나온다.
console.log(str.name); // undefined
```

이러한 래퍼 객체 덕분에 String, Number, Boolean은 new 연산자와 호출하여 인스턴스를 생성할 필요가 없어진다.(권장하지도 않음)
