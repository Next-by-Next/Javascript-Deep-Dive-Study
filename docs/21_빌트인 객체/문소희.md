# 🚀 빌트인 객체

## 🔎 1. 자바스크립트 객체의 분류

### ✨ 표준 빌트인 객체<sup>standard built-in objects/native objects/global objects</sup>

- ECMAScript 사양에 정의된 객체로, 애플리케이션 전역의 공통 기능 제공
- 자바스크립트 실행 환경에 관계없이 언제나 사용 가능
- 전역 객체의 프로퍼티로서 제공 (별도의 선언 없이 전역 변수처럼 언제나 참조 가능)

### ✨ 호스트 객체<sup>host objects</sup>

- ECMAScript 사양에 정의되어 있지는 않지만 자바스크립트 실행 환경에서 추가로 제공하는 객체
- 브라우저 환경에서는 클라이언트 사이드 Web API를 호스트 객체로 제공
- Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공

### ✨ 사용자 정의 객체<sup>user-defined objects</sup>

- 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체

## 🔎 2. 표준 빌트인 객체

Math, Reflect, JSON을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다. 이는 프로토타입 메서드와 정적 메서드를 제공하고, 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다. 👀

```javascript
// 표준 빌트인 객체인 String, Number, Boolean, Function, Array, Date 생성자 함수로 호출해 인스턴스 생성 가능

// Function 생성자 함수에 의한 Function 객체(함수) 생성
const func = new Function('x', 'return x + y'); // f anonymous(x )
console.log(typeof func); // function

// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성
const regExp = new RegExp(/ab+c/i); // ab+c/i
console.log(typeof regExp); // object
```

생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체다.

```javascript
// String 생성자 함수에 의한 String 객체 생성
const strObj = new String('Lee'); // String {"Lee"}

// String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype
console.log(Object.getPrototypeOf(strObj) === String.prototype); // true
```

표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체는 다양한 기능의 빌트인 프로토타입 메서드를 제공한다. 또한 인스턴스 없이도 호출 가능한 빌트인 정적 메서드를 제공한다!

```javascript
const numObj = new Number(1.5); // Number {1.5}

// toFixed: Number.prototype의 프로토타입 메서드
console.log(numObj.toFixed()); // 2

// isInteger: Number의 정적 메서드 (인스턴스 없이 정적으로 호출 가능)
console.log(Number.isInteger(0.5)); // false
```

### 🔎 3. 원시값과 래퍼 객체

원시값은 객체가 아니므로 프로퍼티나 메서드를 가질 수 없지만, 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성해 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.

이처럼 **문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체<sup>wrapper object</sup>라고 한다.**

```javascript
const str = 'hi';

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환됨
consol.log(str.length);
console.log(str.toUpperCase());

// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌림
console.log(typeof str); // string
```

이때 문자열 래퍼 객체인 String 생성자 함수의 인스턴스는 String.prototype 메서드를 상속받아 사용 가능하다!

![prototype-chain](https://images.velog.io/images/gavri/post/bebfbdbf-0453-4f98-9d1b-0325e5c16d7f/image.png)

래퍼 객체의 처리가 종료되면 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값으로 원래의 상태, 즉 식별자가 원시값을 갖도록 되돌리고 래퍼 객체는 가비지 컬렉션의 대상이 된다.

```javascript
// ① 식별자 str은 문자열을 값으로 가짐
const str = 'hello';

// ② 식별자 str은 암묵적으로 생성된 래퍼 객체를 가리킴
// 식별자 str의 값 'hello'는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당
// 래퍼 객체에 name 프로퍼티 동적 추가
str.name = 'Lee';

// ③ 식별자 str은 다시 원래의 문자열, 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값 가침
// ②에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상

// ④ 식별자 str은 새롭게 암묵적으로 생성된 래퍼 객체 가리킴 (②와 다름)
// 새롭게 생성된 래퍼 객체에는 name 프로퍼티가 존재하지 않음
console.log(str.name); // undefined

// ⑤ 식별자 str은 다시 원래의 문자열, 즉 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값 가짐
// ④에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상
console.log(typeof str, str); // string hello
```

## 👀 REFERENCE

모던 자바스크립트 Deep Dive 21장 빌트인 객체
