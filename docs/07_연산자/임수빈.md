# 🗓DAY5 - 연산자[1]

---

## 💭연산자

연산자

- 산술 연산자
- 할당 연산자
- 비교 연산자
- 논리 연산자
- 타입 연산자
- 지수 연상자

연산자는 하나 이상의 `표현식`을 대상으로 연산을 수행하여 하나의 값을 만든다

연산의 대상을`피연산자` 이 피연산자는 값으로 평가될 수 있는 표현식, 즉 `변수에 할당이 가능한`상태여야한다.

> 복기 하기 🔎
> 값으로 평가될 수 있는 문은 모두 표현식!

---

## 💭산술 연산자

산술 연산자는 피연산자를 대상으로 `수학적 계산`을 수행

이항 산술 연산자 (2개의 피연산자)

- 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값은 만들어냄
- +,-,\*,/,%

단항 산술 연산자(1개의 피연산자)

- 피연산자의 값을 변경함
- ++,--,+,-
- 문자열 연결 연산자
- 피연사중 하나 이상이 문자열이면 + 는 문자열 연결 연산자로 동작함

```javascript
'1'+2 = 12
```

이를 개발자의 의도와는 상관없이 js엔진이 암묵적 타입 변환, 타입 강제변환 이라고 한다

---

## 💭할당 연산자

우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당해 변수 값이 변하는 부수 효과가 있다.

할당연산자

- =, +=, -=, \*=, /=, %=

```javascript
var x;
x=10;
x+=5; =>15
x-=5; =>5
```

그럼 할당문은 표현식인 문일까?
변수에 할당해보자

```javascript
var x;
x=10;

var A = (x=10); -> A=10
```

10으로 인식되어 할당이 가능하므로 할당문은 값으로 평가되는 표현식인 문이다.

> 복기 하기 🔎
> 표현식은 값으로 평가될 수 있는 문이고 문은 표현식인 문과 표현식이 아닌문이있다.

---

## 💭비교 연산자

좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 변환한다.

동등 비교 연산자 '=='

- 느슨한 비교
- 비교시 강제로 타입변환을해 정말 값이 동등한지를 비교
- 하지만 결과를 예측하기 어렵다

```javascript
5 =='5'; ->true
```

일치 비교 연산자 '==='

- 엄격한 비교
- 타입과 값이 일치해야한다

```javascript
5 ==='5'; ->false
5===5; -> true

NaN === NaN -> false //NaN은 자기자신과 일치하지 않음
```

대소 관계 비교 연산자

- > , <, >=, <= -피연산자의 크기를 비교해서 불리언 값을반환

---

## 💭삼항 조건 연산자

삼항 조건 연산자는 조건의 평가 결과에 따라 값을 반환한다.
var result = score>90? 참: 거짓

그럼 else if문과 다른점이 뭘까?

- `값으로 사용할 수 있냐 없냐`이다 즉 변수에 할당할 수 있는가이고 else if문은 변수에 할당할 수 없다.

---

## 💭논리 연산자

우항과 좌항의 피연산자를 논리 연산 함

- || or [하나라도 참이면 참임]
  11->1
  10->1
  01->1
  00->0

- && and [하나라도 참이 아니면 거짓임]
  11->1
  10->0
  01->0
  00->1

- ! not
  !true -> false
  !false -> true

---

# 🗓DAY6 - 연산자[2]

---

## 💭쉼표 연산자

쉼표 연산자는 왼쪽 부터 차례대로 피연산자를 평가하고 평가가끝나면 `마지막 피연산`자의 결과를 반환한다

```javascript
var x, y, z;
(x = 1), (y = 2), (z = 3); // 3, 마지막 피연산자의 값이 3이기 때문
```

> 복기 하기 🔎
> 값으로 평가될 수 있는 문은 모두 표현식!

---

## 💭그룹 연산자

`()` 로 피연산자를 감싸서 사용되고 그룹연산자로 감싸진 표현식은 `연산자 우선순위`가 가장 높다

```javascript
10 + 2 * 3 = 16
(10 + 2) * 3 = 36
```

---

## 💭typeof 연산자

피연산자의 데이터 타입이 궁금할때 사용된다, 즉 피연산자의 데이터 타입을 문자열로 반환한다

데이터 타입의 종류

- string
- number
- boolean
- undefined
- symbol
- object
- function

하지만 `null`값을 그자체로 은 반환하지 않는다. null피연산자에 typeof연산자를 사용하면 `object`를 반환한다. 하지만 이것은 js의 첫번째 버그다

> 중요 포인트 🔎
> 데이터 타입이 null인가를 확일할땐 === 연산자를 사용하여야 한다.

> 선언하지 않은 식별자에 typeof를 사용하면 undefined가 반환된다.

---

## 💭지수 연산자

지수 연산자는 `ES7`에서 도입되었다
좌항의 피연산자는 밑
우황의 피연산자는 지수
로 취급해 거듭 제곱을 할 수 있다.
`**`를 사용한다.

```javascript
2 ** 2; //4
2 ** 2.5; //5.6568...
```

어라? 그럼 기본적으로 ES6를 많이 사용하는데 여기선 지수 표현을 어떻게 사용했더라? 🤔
-> `Math.pow(밑,지수)`를 사용했다

> 중요 포인트 🔎
> 지수 연산자가 Math.pow()보다 가독성이 더 좋다는 장점을 가지고 있다.
> 할당연산자와 함께 사용이 가능하다

---

## 💭그 외의 연산자

| 연산자     | 개요                                                        |
| ---------- | ----------------------------------------------------------- |
| ?.         | 옵셔널 체이닝 연산자                                        |
| ??         | null 병합 연산자                                            |
| delete     | 프로퍼티 삭제                                               |
| new        | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성            |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인슨턴스인지 판별 |
| in         | 프로퍼티 존재 확인                                          |

---

## 💭연산자의 부수 효과

연산자의 부수 효과?

- 대부분 코드에 영향을 주지 않는 연산자들과 다르게 다른 코드에 `부수효과`를 주는 연산자들이 있다

- 할당연산자 =
- 증감소 연산자 ++ --
- delete 연산자

이것들은 값을 코드의 값을 변경하는 부수효과가 있다.

---

## 💭연산자의 우선순위

연산자 종류가 많다보니 모두 기억하기는 사실 어렵다.

잘 사용하는것들의 순위는 이렇다
그룹연산자 > 후위 증감소 > 전위증감소 ..

하지만 `그룹연산자`를 통해서 명시적으로 우선순위를 조절하는걸 권장한다.

---

## 💭연산자 결합 순서

연산자의 좌항과 우항 중 어디 부터 평가를 수행할것인지를 나타낸다
| 결합 순서 | 연산자 |
| ---------------- | ------ |
| 좌항 -> 우항 | +, -, /, %, <, <=, >, >=, &&, ||, ., [], (), ??, ?., in, instanceof |
| 우항->좌항 | ++, --, 할당연산자, !x, +x, -x, ++x, --x, typeof, delete, ? |

---
