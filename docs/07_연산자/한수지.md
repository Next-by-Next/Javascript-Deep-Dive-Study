## 연산자

> `연산자`는 하나 이상의 표현식을 대상으로 `산술, 할당, 비교, 논리, 타입, 지수 연산` 등을 수행해 **하나의 값을 만든다.**

- 피연산자 : 연산의 대상 (= 값으로 평가될 수 있는 표현식)

연산자 표현식(피연산자와 연산자의 조합)도 값으로 평가될 수 있는 표현식이여야 한다.

### 산술 연산자

> `산술 연산자`는 피연산자를 대상으로 `수학적 계산을 수행해 새로운 숫자 값`을 만든다.

이때, **산술 연산이 불가능**한 경우에는 `NaN`을 반환한다.

```js
console.log(5 - "a"); // NaN
```

#### 이항 산술 연산자 (2개의 피연산자)

![](https://velog.velcdn.com/images/ninto_2/post/cef165cc-06af-4ab0-9e19-b7bd52e479f4/image.png)

> `이항 산술 연산자`는 `2개의 피연산자를 산술 연산하여 숫자 값`을 만든다.

어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만든다. (부수효과 x)

대표적으로 이항 산술연산자에는 **덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산자**가 존재한다.

- 부수효과 : 좌항의 변수에 값을 할당하며 변수의 값이 바뀌는 것

#### 단항 산술 연산자 (1개의 피연산자)

![](https://velog.velcdn.com/images/ninto_2/post/de5d5998-67d2-4670-871f-5d1ad7d38d23/image.png)

> `단항 산술 연산자`는 `1개의 피연산자를 산술 연산하여 숫자 값`을 만든다.

#### 증감 연산자의 특징

증가(++), 감소(--) 연산자는 피연산자의 값을 변경하는 부수효과가 있다.
즉, **증감연산을 하면 피연산자의 값을 변경하는 암묵적 할당**이 이뤄진다.

또한 증감연산자는 **위치에 의미**가 있다.

- `전위 증가/감소 연산자` : 피연산자 앞에 위치하면 먼저 피연산자의 값을 증감시킨후 다른 연산을 수행한다.
- `후위 증가/감소 연산자` : 피연산자 뒤에 위치하면 다른 연산을 수행후, 피연산자의 값을 증감시킨다.

```js
// 전위 증가 연산자
++x;

// 후위 증가 연산자
y++;
```

자바스크립트 코드 컨벤션에 의하면, 증감 연산자의 사용보다 아래와 같이 명시적으로 코드를 작성하는걸 지향하고 있다.

```js
// bad
a++;

// good
a += 1;
```

#### 단항 +/- 연산자

- `+ 단항 연산자`

숫자 타입이 아닌 피연산자에 `+단항 연산자`를 사용하면 피연산자를 `숫자 타입으로 변환`한다.
이때 피연산자를 변경하는 것이 아니고 `숫자 타입으로 변환한 값을 생성해서 반환`한다.

```js
const x = "1";
console.log(+x); // 1

const y = true;
const z = false;
console.log(+y, +z); // 1 0

const name = "foo";
console.log(+name); // NaN
```

불리언 값은 숫자타입으로 변환하지만, 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.

- `- 단항 연산자`

`-단항 연산자`는 피연산자의 부호를 반전한 값을 반환한다.
`+단항 연산자`연사자와 마찬가지로 숫자타입으로 변환한 값을 생성해서 반환하지만 부수효과는 없다.

#### 문자열 연결 연산자

> `+ 연산자`는 파연산자 중 `하나 이상이 문자열인 경우 문자열 연결 연산자로 동작`한다. (문자타입을 우선시함)

```js
// 피연산자의 값이 숫자여도 타입이 문자열인 경우 문자열 연결 연산자로 동작한다.
"1" + 2; // '12'
```

이처럼, 자바스크립트 엔진은 암묵적으로 타입을 강제 변환한 후 연산을 수행한다.
이를 **암묵적 타입 변환** 또는 **타입 강제 변환**이라고 한다.

참고: 딥다이브 9장

---

### 할당 연산자

![](https://velog.velcdn.com/images/ninto_2/post/0580502c-4939-4fb5-ba9e-fd728af88f5a/image.png)

> `할당 연산자`는 우항에 있는 `피연산자의 평가 결과를 좌항에 있는 변수에 할당`한다.

- 연쇄 할당 : 오른쪽에서 왼쪽으로 진행된다.

```js
// 오른쪽에서 왼쪽으로 평가 진행
a = b = c = 0; // 0 0 0
```

---

### 비교 연산자

> 비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 `불리언 값으로 반환`한다.
> (주로 if문이나 for문과 같은 **제어문의 조건식에 사용**된다.)

#### 동등/일치 비교 연산자

![](https://velog.velcdn.com/images/ninto_2/post/6c5b0580-9431-4d8e-837b-fbc400a066c3/image.png)

`동등 비교(==), 부동등 비교(!==) 연산자`는 `타입을 변환시켜 맞춘 상태로 비교`한다.
즉, 피연산자를 비교할 대 먼저 **암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교**한다. (암묵적 타입 변환은 피해야한다.)

암묵적 타입 변환은 예측하기 어려운 결과를 만들어내므로, `동등 비교(==), 부동등 비교(!==) 연산자`는 `사용하지 않는게 좋다.` (**일치비교, 불일치 비교 사용을 지향**함)

#### NaN의 일치 비교

일치 비교 연산자에서 `NaN을 주의`해야한다.

```js
NaN === NaN; // false

// 빌트인 함수 사용
Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined); // true
```

이럴때 숫자가 NaN인지 조사하기 위해서 빌트 함수`Number.isNaN`을 사용한다.

#### 대소 관계 비교 연산자

![](https://velog.velcdn.com/images/ninto_2/post/40d9c385-ef17-445c-9a51-388a07272867/image.png)

> `대소 관계 비교 연산자`는 피연산자의 `크기를 비교하여 불리언 값을 반환`한다.

---

### 삼항 조건 연산자

![](https://velog.velcdn.com/images/ninto_2/post/d5665c0b-e9d0-4519-890f-ae756ff567a9/image.png)

> 삼항 조건 연산자 표현식은 `값으로 평가할 수 있는 표현식인 문`이다.

삼항 조건 연산자 표현식은 값처럼 사용할 수 있으나 if,else문은 값처럼 사용 불가하다.

---

### 논리 연산자

> `논리 연산자`는 우항과 좌항의 피연산자(부정 논리 연산의 경우 우항의 피연산자)를 `논리 연산`한다.

![](https://velog.velcdn.com/images/ninto_2/post/64ed2729-2e01-4a67-84ca-bf13ad914e4f/image.png)

```js
// 논리합(||) 연산자 or
true || true; // true
true || false; // true
false || true; // true
false || false; // false

// 논리곱(&&) 연산자 and
true && true; // true
true && false; // false
false && true; //  false
false && false; // false

// 논리부정(!)연산자 not
!true; // false
!false; // true
```

`논리 부정 연산자`는 언제나 불리언 값을 반환한다.
피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환이 된다.

`논리합 또는 논리곱 연산자 표현식`은 언제나 2개의 피연산자 중 `어느 한쪽으로 평가`된다.

참고: 딥다이브 9.4절 단축평가

---
