## 연산자

> `연산자`는 하나 이상의 표현식을 대상으로 `산술, 할당, 비교, 논리, 타입, 지수 연산` 등을 수행해 **하나의 값을 만든다.**

- 피연산자 : 연산의 대상 (= 값으로 평가될 수 있는 표현식)

연산자 표현식(피연산자와 연산자의 조합)도 값으로 평가될 수 있는 표현식이여야 한다.

### 산술 연산자

> `산술 연산자`는 피연산자를 대상으로 `수학적 계산을 수행해 새로운 숫자 값`을 만든다.

이때, **산술 연산이 불가능**한 경우에는 `NaN`을 반환한다.

```js
console.log(5 - "a"); // NaN
```

#### 이항 산술 연산자 (2개의 피연산자)

![](https://velog.velcdn.com/images/ninto_2/post/cef165cc-06af-4ab0-9e19-b7bd52e479f4/image.png)

> `이항 산술 연산자`는 `2개의 피연산자를 산술 연산하여 숫자 값`을 만든다.

어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없고 언제나 새로운 값을 만든다. (부수효과 x)

대표적으로 이항 산술연산자에는 **덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산자**가 존재한다.

- 부수효과 : 좌항의 변수에 값을 할당하면 변수의 값이 바뀌는 것

#### 단항 산술 연산자 (1개의 피연산자)

![](https://velog.velcdn.com/images/ninto_2/post/de5d5998-67d2-4670-871f-5d1ad7d38d23/image.png)

> `단항 산술 연산자`는 `1개의 피연산자를 산술 연산하여 숫자 값`을 만든다.

#### 증감 연산자의 특징

증가(++), 감소(--) 연산자는 피연산자의 값을 변경하는 부수효과가 있다.
즉, **증감연산을 하면 피연산자의 값을 변경하는 암묵적 할당**이 이뤄진다.

또한 증감연산자는 **위치에 의미**가 있다.

- `전위 증가/감소 연산자` : 피연산자 앞에 위치하면 먼저 피연산자의 값을 증감시킨후 다른 연산을 수행한다.
- `후위 증가/감소 연산자` : 피연산자 뒤에 위치하면 다른 연산을 수행후, 피연산자의 값을 증감시킨다.

```js
// 전위 증가 연산자
++x;

// 후위 증가 연산자
y++;
```

자바스크립트 코드 컨벤션에 의하면, 증감 연산자의 사용보다 아래와 같이 명시적으로 코드를 작성하는걸 지향하고 있다.

```js
// bad
a++;

// good
a += 1;
```

#### 단항 +/- 연산자

- `+ 단항 연산자`

숫자 타입이 아닌 피연산자에 `+단항 연산자`를 사용하면 피연산자를 `숫자 타입으로 변환`한다.
이때 피연산자를 변경하는 것이 아니고 `숫자 타입으로 변환한 값을 생성해서 반환`한다.

```js
const x = "1";
console.log(+x); // 1

const y = true;
const z = false;
console.log(+y, +z); // 1 0

const name = "foo";
console.log(+name); // NaN
```

불리언 값은 숫자타입으로 변환하지만, 문자열은 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.

- `- 단항 연산자`

`-단항 연산자`는 피연산자의 부호를 반전한 값을 반환한다.
`+단항 연산자`연사자와 마찬가지로 숫자타입으로 변환한 값을 생성해서 반환하지만 부수효과는 없다.

#### 문자열 연결 연산자

> `+ 연산자`는 파연산자 중 `하나 이상이 문자열인 경우 문자열 연결 연산자로 동작`한다. (문자타입을 우선시함)

```js
// 피연산자의 값이 숫자여도 타입이 문자열인 경우 문자열 연결 연산자로 동작한다.
"1" + 2; // '12'
```

이처럼, 자바스크립트 엔진은 암묵적으로 타입을 강제 변환한 후 연산을 수행한다.
이를 **암묵적 타입 변환** 또는 **타입 강제 변환**이라고 한다.

참고: 딥다이브 9장

---

### 할당 연산자

![](https://velog.velcdn.com/images/ninto_2/post/0580502c-4939-4fb5-ba9e-fd728af88f5a/image.png)

> `할당 연산자`는 우항에 있는 `피연산자의 평가 결과를 좌항에 있는 변수에 할당`한다.

- 연쇄 할당 : 오른쪽에서 왼쪽으로 진행된다.

```js
// 오른쪽에서 왼쪽으로 평가 진행
a = b = c = 0; // 0 0 0
```

---

### 비교 연산자

> 비교 연산자는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 `불리언 값으로 반환`한다.
> (주로 if문이나 for문과 같은 **제어문의 조건식에 사용**된다.)

#### 동등/일치 비교 연산자

![](https://velog.velcdn.com/images/ninto_2/post/6c5b0580-9431-4d8e-837b-fbc400a066c3/image.png)

`동등 비교(==), 부동등 비교(!==) 연산자`는 `타입을 변환시켜 맞춘 상태로 비교`한다.
즉, 피연산자를 비교할 대 먼저 **암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교**한다. (암묵적 타입 변환은 피해야한다.)

암묵적 타입 변환은 예측하기 어려운 결과를 만들어내므로, `동등 비교(==), 부동등 비교(!==) 연산자`는 `사용하지 않는게 좋다.` (**일치비교, 불일치 비교 사용을 지향**함)

#### NaN의 일치 비교

일치 비교 연산자에서 `NaN을 주의`해야한다.

```js
NaN === NaN; // false

// 빌트인 함수 사용
Number.isNaN(NaN); // true
Number.isNaN(10); // false
Number.isNaN(1 + undefined); // true
```

이럴때 숫자가 NaN인지 조사하기 위해서 빌트 함수`Number.isNaN`을 사용한다.

#### 대소 관계 비교 연산자

![](https://velog.velcdn.com/images/ninto_2/post/40d9c385-ef17-445c-9a51-388a07272867/image.png)

> `대소 관계 비교 연산자`는 피연산자의 `크기를 비교하여 불리언 값을 반환`한다.

---

### 삼항 조건 연산자

![](https://velog.velcdn.com/images/ninto_2/post/d5665c0b-e9d0-4519-890f-ae756ff567a9/image.png)

> 삼항 조건 연산자 표현식은 `값으로 평가할 수 있는 표현식인 문`이다.

삼항 조건 연산자 표현식은 값처럼 사용할 수 있으나 if,else문은 값처럼 사용 불가하다.

---

### 논리 연산자

> `논리 연산자`는 우항과 좌항의 피연산자(부정 논리 연산의 경우 우항의 피연산자)를 `논리 연산`한다.

![](https://velog.velcdn.com/images/ninto_2/post/64ed2729-2e01-4a67-84ca-bf13ad914e4f/image.png)

```js
// 논리합(||) 연산자 or
true || true; // true
true || false; // true
false || true; // true
false || false; // false

// 논리곱(&&) 연산자 and
true && true; // true
true && false; // false
false && true; //  false
false && false; // false

// 논리부정(!)연산자 not
!true; // false
!false; // true
```

`논리 부정 연산자`는 언제나 불리언 값을 반환한다.
피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환이 된다.

`논리합 또는 논리곱 연산자 표현식`은 언제나 2개의 피연산자 중 `어느 한쪽으로 평가`된다.

참고: 딥다이브 9.4절 단축평가

---

### 쉼표 연산자

> `쉼표 연산자(`,`)`는 `왼쪽` 피연산자부터 `차례대로 피연산자를 평가`하고, 마지막 피연산자의 평가가 끝나면 `마지막 피연산자의 평가 결과를 반환`한다.

```js
const x, y, z;
x = 1, y = 2, z = 3; // 3
```

하지만 쉼표 연산자는 가독성이 좋지 않으므로 위와 같은 경우 차라리 3줄로 코드를 작성하는 것이 더 나을 수 있다.

---

### 그룹 연산자

> `그룹 연산자()`는 자신의 피연자인 표현식을 `가장 먼저 평가`한다.

그룹 연산자를 사용하면 연산자의 우선순위를 조절 할 수 있다. (= 연산자 우선순위가 가장 높음)

```js
10 * (2 + 3); // 50
```

그룹 연산자를 잘 활용하면 코드의 가독성을 향상시킬 수 있다.

---

### typeof 연산자

> `typeof`연산자는 피연산자의 `데이터 타입을 문자열로 반환`한다.

7가지 문자열 `'string', 'number', 'boolean', 'undefined', 'symbol', 'object', 'function'`중 하나를 반환한다.

- 예외 케이스 `typeof null`

이때, `'null'`이 없는 이유는 아래와 같이 `typeof null`을 실행하면 `object`를 반환하기 때문이다. (= 자바스크립트의 첫번째 버전의 버그)

```js
console.log(typeof null); // 'object'
```

- 예외 케이스 `typeof NaN`

이 외에도 `NaN`같은 경우 계산할 수 없는 숫자를 의미하므로, `typeof`를 실행하면 `'number'`가 나온다.

```js
console.log(typeof NaN); // 'number'
```

하지만 NaN은 숫자가 아니므로, `typeof`를 사용해서 숫자인지 검증할때는 이러한 예외의 경우도 함께 고려해야 한다.

---

### 지수 연산자

> `지수 연산자` (`**`)는 좌항의 피연산자를 밑(base)으로, 우항의 피연산자를 지수(exponent)로 `거듭 제곱하여 숫자 값을 반환`한다.

지수 연산자는 ES7에서 도입되었으며, 같은 기능을 제공하는 `Math.pow()`를 사용했다.
하지만 `Math.pow()`보다 **지수 연산자의 가독성이 더 좋다.**

```js
2 ** 2; // 4

Math.pow(2, 2); // 4
```

지수 연산자는 **이항연산자 중 우선순위가 가장 높다.**

- 이항 연산자: 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지

```
2 * 5 ** 2; // 50 마치 그룹연산자가 생략된 것 처럼 먼저 지수연산이 실행됨

2 * (5 ** 2); // 50
```

- 음수의 거듭제곱

음수를 거듭제곱의 밑으로 사용해 계산하려면 괄호를 사용해 묶어야 한다. (괄호를 사용하지 않으면 에러남)

```js
(-5) ** 2; // 25
```

---

### 그 외의 연산자

![](https://velog.velcdn.com/images/ninto_2/post/1416ba91-b7f8-48fd-ae27-d508ab89838d/image.png)

이번 장에선 위 연산자에 대한 내용을 다루지 않으므로, **기재된 딥다이브 챕터를 참고**한다.

---

### 연산자의 부수 효과

> 부수효과는 다른 코드에 영향을 준다.

- 부수 효과가 있는 연산자 : `할당 연산자(=), 증가/감소 연산자(++,--), delete 연산자`

---

### 연산자 우선순위

> 연산자에는 우선순위가 존재하며, `우선순위가 높을수록 먼저 실행`된다.

![](https://velog.velcdn.com/images/ninto_2/post/81d7e786-a9d5-4aca-9d17-10a31de11b3f/image.png)

---

### 연산자 결합 순서

> 연산자에는 `결합순서`가 존재하며, `어느쪽부터 평가를 수행할 것`인지 나타내는 순서를 말한다.

![](https://velog.velcdn.com/images/ninto_2/post/5f5c28c1-c276-4c28-89e0-c302e5855042/image.png)
